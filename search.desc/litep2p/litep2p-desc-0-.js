searchState.loadedDescShard("litep2p", 0, "Bandwidth sink which provides metering for …\nConnection closed to remote peer.\nConnection established to peer.\nFailed to dial peer.\nContains the error value\nA list of multiple dial failures.\n<code>Litep2p</code> object.\nLitep2p events.\nContains the success value\nIdentifier of a peer of the network.\nPublic result type used by the crate.\nAdd one ore more known addresses for peer.\nGet handle to bandwidth sink.\nProtocol codecs.\n<code>Litep2p</code> configuration.\nCrypto-related code.\nDial peer.\nDial address.\n<code>Litep2p</code> error types.\nBehavior defining how futures running in the background …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>PeerId</code> from bytes.\nTries to turn a <code>Multihash</code> into a <code>PeerId</code>.\nBuilds a <code>PeerId</code> from a public key.\nGet total the number of bytes received.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the public key passed as parameter matches …\nGet the list of listen addresses of the node.\nGet local peer ID.\nCreate new <code>Litep2p</code>.\nPoll next event.\nGet total the nubmer of bytes sent.\nProtocol-related defines.\nGet the list of public addresses of the node.\nGenerates a random peer ID from a cryptographically secure …\nSubstream-related helper code.\nReturns a base-58 encoded string of this <code>PeerId</code>.\nReturns a raw bytes representation of this <code>PeerId</code>.\nTransport protocol implementations provided by <code>Litep2p</code>.\nTries to extract a <code>PeerId</code> from the given <code>Multiaddr</code>.\nTypes used by <code>Litep2p</code> protocols/transport.\nThis crate implements the Yamux specification.\nAddress of the peer.\nConnection ID.\nEndpoint.\nDial error.\nList of errors.\nRemote peer ID.\nPeer ID.\nThe address contains a different peer ID than the local …\nThe address is empty.\nThe error returned when an address cannot be inserted.\nSet of the public addresses of the local node.\nAdd a public address to the list of addresses.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a vector of the available listen addresses.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove the exact public address.\nIdentity codec where the argument denotes the payload size.\nSupported protocol codecs.\nUnsigned varint where the argument denotes the maximum …\nProtocol doens’t need framing for its messages or is …\nReturns the argument unchanged.\nIdentity codec that reads/writes <code>N</code> bytes from/to …\nCalls <code>U::from(self)</code>.\n<code>unsigned-varint</code> codec.\nIdentity codec.\nEncode <code>payload</code> using identity codec.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>Identity</code> codec.\nUnsigned varint codec.\nDecode <code>payload</code> into <code>BytesMut</code>.\nEncode <code>payload</code> using <code>unsigned-varint</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>UnsignedVarint</code> codec.\nSet maximum size for encoded/decodes values.\nConfiguration builder for <code>Litep2p</code>.\nDialer.\nListener.\nConfiguration for <code>Litep2p</code>.\nConnection role.\nBuild <code>Litep2pConfig</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate empty <code>ConfigBuilder</code>.\nSet connection limits configuration.\nAdd executor for running futures spawned by <code>litep2p</code>.\nSet keep alive timeout for connections.\nAdd keypair.\nAdd known address(es) for one or more peers.\nEnable IPFS Bitswap protocol.\nEnable IPFS Identify protocol.\nEnable IPFS Kademlia protocol.\nEnable IPFS Ping protocol.\nHow many addresses should litep2p attempt to dial in …\nEnable mDNS for peer discoveries in the local network.\nEnable notification protocol.\nEnable request-response protocol.\nAdd TCP transport configuration, enabling the transport.\nEnable user protocol.\nAdd WebSocket transport configuration, enabling the …\nA public Ed25519 key.\nThe public key of a node’s identity keypair.\nEd25519 keys.\nReturns the argument unchanged.\nDecode a public key from a protobuf structure, e.g. read …\nCalls <code>U::from(self)</code>.\nConvert the <code>PublicKey</code> into the corresponding <code>PeerId</code>.\nEncode the public key into a protobuf structure for …\nVerify a signature for a message using this public key, …\nAn Ed25519 keypair.\nAn Ed25519 public key.\nAn Ed25519 secret key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a new random Ed25519 keypair.\nGenerate a new Ed25519 secret key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the public key of this keypair.\nGet the secret key of this keypair.\nSign a message using the private key of this keypair.\nConvert the keypair into a byte array by concatenating the …\nConvert the public key to a byte array in compressed form, …\nConvert this secret key to a byte array.\nConvert public key to <code>PeerId</code>.\nTry to parse a keypair from the binary format produced by …\nTry to parse a public key from a byte array containing the …\nTry to parse an Ed25519 secret key from a byte slice …\nVerify the Ed25519 signature on a message using the public …\nError type for address parsing.\nThe provided address for dialing is invalid.\nNo address is available for the provided peer ID.\nCannot dial an already connected peer.\nThe channel is clogged.\nThe error type for dialing a peer.\nError during DNS resolution.\nAn error occurred during DNS lookup operation.\nDialing resulted in an immediate error before performing …\nThe provided date has an invalid format.\nThe provided address contains an invalid multihash.\nThe provided address does not correspond to the transport …\nThe public key bytes are invalid and cannot be parsed.\nThe provided address is not a valid URL.\nAn I/O error occurred during the negotiation process.\nThe DNS expected a different IP address version.\nError occurred during the multistream-select phase of the …\nError during the negotiation phase.\nAn error occurred during the negotiation process.\nCannot dial a peer that does not have any address …\nThe message provided over the wire has an invalid format …\nThe noise handshake provided a different peer ID than the …\nThe provided address does not include a peer ID.\nThe peer ID was not provided by the noise handshake.\nThe provided address does not include a peer ID.\nThe provided probuf message cannot be decoded.\nThe provided protobuf message cannot be encoded.\nThe DNS resolution failed to resolve the provided URL.\nError occurred during the Noise handshake negotiation.\nExpected a different state during the negotiation process.\nThe essential task was closed.\nThe negotiation operation timed out.\nThe dialing operation timed out.\nThe peer ID provided in the address is the same as the …\nThe protobuf message contains an unexpected key type.\nError specific to the WebSocket transport.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrait which defines the interface the executor must …\nStart executing a future in the background.\nStart executing a future in the background and give the …\nConnection closed to peer.\nConnection established to <code>peer</code>.\nFailed to dial peer.\nSubstream direction.\nSubstream was opened by the remote peer.\nSubstream was opened by the local peer.\nFailed to open substream.\nSubstream opened for <code>peer</code>.\nEvents emitted by one of the installed transports to …\nProvides an interfaces for <code>Litep2p</code> protocols to interact …\nTrait defining the interface for a user protocol.\nAdd one or more addresses for <code>peer</code>.\nGet user protocol codec.\nDial <code>peer</code> using <code>PeerId</code>.\nDial peer using a <code>Multiaddr</code>.\nForcibly close the connection, even if other protocols …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSupported <code>libp2p</code> protocols.\nGet the list of listen addresses of the node.\nGet local peer ID.\nMulticast DNS implementation.\nNotification protocol implementation.\nOpen substream to <code>peer</code>.\nGet user protocol name.\nGet the list of public addresses of the node.\nRequest-response protocol implementation.\nStart the the user protocol event loop.\nDialed address.\nSubstream direction.\nEndpoint.\nError that occurred when the substream was being opened.\nFallback protocol.\nPeer ID.\nPeer ID.\nPeer ID.\nPeer ID.\nProtocol name.\nSubstream.\nSubstream ID.\n<code>/ipfs/bitswap/1.2.0</code> implementation.\n<code>/ipfs/identify/1.0.0</code> implementation.\n<code>/ipfs/kad/1.0.0</code> implementation.\n<code>/ipfs/ping/1.0.0</code> implementation.\nEvents emitted by the bitswap protocol.\nHandle for communicating with the bitswap protocol.\nBlock.\nA Cid that contains a multihash with an allocated size of …\nBitswap configuration.\nPresense.\nBitswap request.\nResponse type for received bitswap request.\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>WantType</code>, or <code>None</code> if <code>value</code> is not a …\nConverts an <code>i32</code> to a <code>BlockPresenceType</code>, or <code>None</code> if <code>value</code> …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>WantType</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>BlockPresenceType</code>.\nCreate new <code>Config</code>.\nSend <code>request</code> to <code>peer</code>.\nSend <code>response</code> to <code>peer</code>.\nRequested CIDs.\nPeer ID.\nFound block.\nCID.\nCID.\nWhether the requested block exists or not.\nIdentify configuration.\nEvents emitted by Identify protocol.\nPeer identified.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Config</code>.\nListen addresses.\nObserved address.\nPeer ID.\nProtocol version.\nSupported protocols.\nUser agent.\nAll peers must be successfully contacted.\nAutomatically add all discovered peers to routing tables.\nAutomatically accept all incoming records.\nKademlia configuration.\nConfiguration builder for Kademlia.\nResult for the issued <code>FIND_NODE</code> query.\n<code>GET_VALUE</code> query succeeded.\nIncoming <code>PUT_VALUE</code> request received.\nIncoming record validation mode.\nKademlia events.\nHandle for communicating with the Kademlia protocol.\nRecord was found in the local store.\nDon’t insert discovered peers automatically to the …\nDon’t insert incoming records automatically to the local …\n<code>N</code> peer must be successfully contacted.\nRecords found in the network.\nOne peer must be successfully contacted.\nA record received by the given peer.\n<code>PUT_VALUE</code> query succeeded.\nQuery failed.\nType representing a query ID.\nQuorum.\nA record stored in the DHT.\nThe (opaque) key of a record.\nThe type of the DHT records.\nRouting table update.\nRouting table update mode.\nAdd known peer.\nBuild Kademlia <code>Config</code>.\nBuild default Kademlia configuration.\nThe expiration time as measured by a local, monotonic …\nSend <code>FIND_NODE</code> query to known peers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet record from DHT.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the record is expired w.r.t. the given …\nKey of the record.\nCreate new <code>ConfigBuilder</code>.\nCreates a new key from the bytes of the input.\nCreates a new record for insertion into the DHT.\nThe peer from whom the record was received\nThe (original) publisher of the record.\nStore record to DHT.\nStore record to DHT to the given peers.\nThe provided record.\nStore the record in the local store. Used in combination …\nCopies the bytes of the key into a new vector.\nTry to add known peer and if the channel is clogged, …\nTry to initiate <code>FIND_NODE</code> query and if the channel is …\nTry to initiate <code>GET_VALUE</code> query and if the channel is …\nTry to initiate <code>PUT_VALUE</code> query and if the channel is …\nTry to initiate <code>PUT_VALUE</code> query to the given peers and if …\nTry to store the record in the local store, and if the …\nValue of the record.\nSet incoming records validation mode.\nSeed Kademlia with one or more known peers.\nSet Kademlia protocol names, overriding the default …\nSet default TTL for the provider records. Recommended …\nSet default TTL for the records.\nSet replication factor.\nSet routing table update mode.\nRecord key.\nFound nodes and their addresses.\nDiscovered peers.\nQuery ID.\nQuery ID.\nQuery ID.\nQuery ID.\nRecord.\nFound records.\nTarget of the query\nPing configuration.\nPing configuration builder.\nPing time with remote peer.\nEvents emitted by the ping protocol.\nBuild <code>Config</code>.\nCreate new <code>Config</code> with default values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new default <code>Config</code> which can be modified by the …\nSet maximum failures the protocol.\nPeer ID.\nMeasured ping time with the peer.\nmDNS configuration.\nOne or more addresses discovered.\nEvents emitted by mDNS.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Config</code>.\nAccept the inbound substream.\nSynchronous notification channel is clogged.\nNotification configuration.\nNotification configuration builder.\nFailed to dial peer.\nDirection of the connection.\nNotification protocol has been closed.\nConnection is considered inbound, i.e., it was initiated …\nConnection to peer doesn’t exist.\nNotification error.\nNotification events.\nHandle allowing the user protocol to interact with the …\nNotification received.\nNotification sink.\nNotification stream closed.\nFailed to open notification stream.\nNotification stream opened.\nConnection is considered outbound, i.e., it was initiated …\nReject the inbound substream.\nRemote rejected the substream.\nValidate substream.\nValidation for a previous substream still pending.\nValidation result.\nBuild notification configuration.\nClose substream to <code>peer</code>.\nClose substream to multiple peers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>ConfigBuilder</code>.\nCreate new <code>Config</code>.\nGet a copy of the underlying notification sink for the …\nOpen substream to <code>peer</code>.\nOpen substreams to multiple peers.\nSend notification to <code>peer</code> asynchronously, waiting for the …\nSend notification to <code>peer</code> asynchronously, waiting for the …\nSend notification to <code>peer</code> synchronously.\nSend notification to <code>peer</code> synchronously.\nSend validation result to the notification protocol for an …\nSet handshake for the protocol.\nSet new handshake.\nTry close substream to multiple peers.\nTry to open substreams to multiple peers.\nConfigure size of the channel for sending asynchronous …\nAuto-accept inbound substreams for those connections which …\nShould <code>NotificationProtocol</code> attempt to dial the peer if an …\nSet fallback names.\nSet handshake.\nSet maximum notification size.\nConfigure size of the channel for sending synchronous …\nDirection of the substream.\nError.\nFallback, if the substream was negotiated using a fallback …\nFallback, if the substream was negotiated using a fallback …\nHandshake.\nHandshake.\nNotification.\nPeer ID.\nPeer ID.\nPeer ID.\nPeer ID.\nPeer ID.\nProtocol name.\nProtocol name.\nRequest was canceled by the local node.\nRequest-response protocol configuration.\nBuilder for <code>Config</code>.\nThe peer disconnected before the request was processed.\nIf the peer is not currently connected, attempt to dial …\nThe dial failed.\nDial behavior when sending requests.\nThe peer is not connected and the dialing option was …\nIf the peer is not connected, immediately reject the …\nThe reason why a request was rejected.\nRequest was rejected.\nRequest failed.\nRequest received from remote\nRequest-response error.\nRequest-response events.\nHandle given to the user protocol which allows it to …\nResponse received.\nThe substream was closed before the request was processed.\nSubstream error.\nRequest timed out.\nToo large payload.\nProtocol not supported.\nBuild <code>Config</code>.\nCancel an outbound request.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>Config</code>.\nCreate new <code>ConfigBuilder</code>.\nReject an inbound request.\nSend request to remote peer.\nSend request to remote peer with fallback.\nSend response to remote peer.\nSend response to remote peer with feedback.\nAttempt to send request to peer and if the channel is …\nAttempt to send request to peer with fallback and if the …\nSet fallback names.\nSpecify the maximum number of concurrent inbound requests. …\nSet maximum message size.\nSet timeout for outbound requests.\nRequest-response error.\nFallback protocol, if the substream was negotiated using a …\nFallback protocol, if the substream was negotiated using a …\nPeer Id.\nPeer Id.\nPeer Id.\nReceived request.\nRequest ID.\nRequest ID.\nRequest ID.\nReceived request.\n<code>Litep2p</code> substream type.\nSubstream set.\nSubstream set key.\nClose the substream.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdd new substream to the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if <code>SubstreamSet</code> is empty.\nGet size of <code>SubstreamSet</code>.\nCreate new <code>SubstreamSet</code>.\nRemove substream from the set.\nSend framed data to remote peer.\nConfiguration for the connection limits.\nError type for connection limits.\nSuccessfully established outbound connection.\nConnection endpoint.\nSuccessfully established inbound connection.\nMaximum number of incoming connections exceeded.\nMaximum number of outgoing connections exceeded.\nGet <code>Multiaddr</code> of the <code>Endpoint</code>.\nGet <code>ConnectionId</code> of the <code>Endpoint</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a listener endpoint?\nConfigures the maximum number of incoming connections that …\nConfigures the maximum number of outgoing connections that …\nTCP transport.\nWebSocket transport.\nAddress that was dialed.\nLocal connection address.\nConnection ID.\nConnection ID.\nTCP transport configuration.\nTCP transport configuration.\nConnection open timeout.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nListen address for the transport.\nEnable <code>TCP_NODELAY</code>.\nNoise read-ahead frame count.\nNoise write buffer size.\nWhether to set <code>SO_REUSEPORT</code> and bind a socket to the …\nSubstream open timeout.\nYamux configuration.\nWebSocket transport configuration.\nWebSocket transport configuration.\nConnection open timeout.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nListen address address for the transport.\nEnable <code>TCP_NODELAY</code>.\nNoise read-ahead frame count.\nNoise write buffer size.\nWhether to set <code>SO_REUSEPORT</code> and bind a socket to the …\nSubstream open timeout.\nYamux configuration.\nConnection ID.\nRequest ID.\nSubstream ID.\nReturns the argument unchanged.\nGet <code>SubstreamId</code> from a number that can be converted into a …\nGet <code>RequestId</code> from a number that can be converted into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>SubstreamId</code>.\nCreate new <code>ConnectionId</code>.\nProtocol name.\nGenerate random <code>ConnectionId</code>.\nError types\nIterator over <code>Multiaddr</code> <code>Protocol</code>s.\nContains the “port” to contact. Similar to TCP or UDP, …\nRepresentation of a Multiaddr.\nRepresents an Onion v3 address\n<code>Protocol</code> describes all possible multiaddress protocols.\nConsume this instance and create an owned version …\nTurn this <code>Protocol</code> into one that owns its data, thus being …\nCreate a new, empty multiaddress.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a single <code>Protocol</code> value from its byte slice …\nParse a protocol value from the given iterator of string …\nReturn the hash of the public key as bytes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the length of this multiaddress is 0.\nReturns the components of this multiaddress.\nReturn the length in bytes of this multiaddress.\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nReturn the port\nReturns &amp;str identifiers for the protocol names themselves.\nAdds an already-parsed address component to the end of …\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nCreate a new, empty multiaddress with the given capacity.\nEncode this protocol by writing its binary representation …\nBLAKE2b-256 (32-byte hash size)\nBLAKE2b-512 (64-byte hash size)\nBLAKE2s-128 (16-byte hash size)\nBLAKE2s-256 (32-byte hash size)\nBLAKE3-256 (32-byte hash size)\nDefault (cryptographically secure) Multihash …\nMultihash error.\nIdentity hash (max. 64 bytes)\nInvalid multihash size.\nIo error.\nKeccak-224 (28-byte hash size)\nKeccak-256 (32-byte hash size)\nKeccak-384 (48-byte hash size)\nKeccak-512 (64-byte hash size)\nA Multihash with the same allocated size as the …\nTrait that implements hashing.\nSHA-256 (32-byte hash size)\nSHA-512 (64-byte hash size)\nSHA3-224 (28-byte hash size)\nSHA3-256 (32-byte hash size)\nSHA3-384 (48-byte hash size)\nSHA3-512 (64-byte hash size)\nUnsupported multihash code.\nInvalid varint.\nCalculate the hash of some input data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a multihash from an existing multihash digest.\nProtocol name.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nClient to server connection.\nAn operation fails because the connection is closed.\nYamux configuration.\nThe various error cases a connection may encounter.\nA Yamux <code>Connection</code> controller.\nWraps a <code>Connection</code> which can be controlled with a <code>Control</code>.\nDecoding a Yamux message frame failed.\nContains the error value\nPossible errors while decoding a message frame.\nA data frame body length is larger than the configured …\nDecoding the frame header failed.\nPossible errors while decoding a message frame header.\nAn underlying I/O error occured.\nAn I/O error.\nHow the connection is used.\nThe whole range of stream IDs has been used up.\nContains the success value\nSend window updates only when data is read on the …\nSend window updates as soon as a <code>Stream</code>’s receive window …\nByte data produced by the <code>futures::stream::Stream</code> impl of …\nServer to client connection.\nA multiplexed Yamux stream.\nThe ID of a stream.\nToo many streams are open, so no further ones can be …\nAn unknown frame type.\nUnknown version.\nSpecifies when window update frames are sent.\nClose the connection.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet this stream’s identifier.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we are still waiting for the remote to acknowledge …\nOpen a new stream to the remote.\nClose the connection.\nPoll for a new outbound stream.\nPoll for the next inbound stream.\nSet the max. buffer size per stream.\nSet the max. number of streams.\nAllow or disallow streams to read from buffered data after …\nSet the receive window per stream (must be &gt;= 256 KiB).\nSet the max. payload size used when sending data frames. …\nSet the window update mode to use.")