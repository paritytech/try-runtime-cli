<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides new integer types with non-standard and fixed bitwidths such as `U24`, `I48`, `U96` and so forth with a focus on data layout and alignment."><title>intx - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="intx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../intx/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../intx/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate intx</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">intx</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/intx/lib.rs.html#1-170">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides new integer types with non-standard and fixed bitwidths
such as <code>U24</code>, <code>I48</code>, <code>U96</code> and so forth with a focus on data layout and alignment.</p>
<ul>
<li>All integers provided by this crate require the minimum number of bytes for their representation.
For example, <code>U24</code> requires 3 bytes, <code>I48</code> requires 6 bytes.</li>
<li>The alignment of all integer types provided by this crate is always 1. If another
alignment is required it is recommended to wrap the integer type in a newtype and
enforce an alignment via <code>#[align(N)]</code>.</li>
<li>As of now the provided integers do not have a rich set of arithmetic methods defined on them.
It is instead expected to convert them to Rust primitive integers, apply the computation and
eventually convert the result back. This might be supported in the future if requested.</li>
<li>The binary representation of integer types provided by this crate is in twos-complement just
like Rust’s built-in integer types.</li>
</ul>
<h3 id="data-layout"><a href="#data-layout">Data Layout</a></h3>
<p>All integer types provided by this crate internally consists of a single byte array.
For example, the structure of <code>U24</code> is <code>struct U24([u8; 3]);</code> allowing for optimal memory
usage and an alignment of 1 (if needed).</p>
<h3 id="api"><a href="#api">API</a></h3>
<p>Integer types provided by this crate only have very a minimal API surface.</p>
<ul>
<li>
<p>Traits implemented by all of the integer types are the following:</p>
<ul>
<li><code>Clone</code>, <code>Copy</code>, <code>Default</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code>, <code>Hash</code>
<ul>
<li>Common traits are all implemented as efficiently as possible for every integer type.</li>
</ul>
</li>
<li><code>Debug</code>, <code>Display</code>, <code>Binary</code>, <code>Octal</code>, <code>LowerHex</code>, <code>UpperHex</code>, <code>LowerExp</code>, <code>UpperExp</code>
<ul>
<li>Integer types mimick the display representation of the next larger Rust built-in integer type.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Endian-aware conversion routines are also implemented:</p>
<ul>
<li><code>from_ne_bytes</code>, <code>to_ne_bytes</code>: Convert from and to native-endian bytes. (always efficient)</li>
<li><code>from_le_bytes</code>, <code>to_le_bytes</code>: Convert from and to little-endian bytes.</li>
<li><code>from_be_bytes</code>, <code>to_be_bytes</code>: Convert from and to big-endian bytes.</li>
</ul>
</li>
<li>
<p>Rich <code>From</code> and <code>TryFrom</code> implementations:</p>
<ul>
<li>All provided integer types have a very rich set of <code>From</code> and <code>TryFrom</code> trait implementations
to efficiently convert between different integer types and Rust built-in integers.</li>
</ul>
</li>
</ul>
<h2 id="example-packed"><a href="#example-packed">Example: Packed</a></h2>
<p>Here the Rust compiler wastes 3 bytes for the discriminent of the <code>enum</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub enum </span>Unpacked {
    A(u32), <span class="comment">// We only use the lowest 24-bit of the integer.
    </span>B(i16),
}
<span class="macro">assert_eq!</span>(core::mem::size_of::&lt;Unpacked&gt;(), <span class="number">8</span>);</code></pre></div>
<p>Using <code>intx::U24</code> the Rust compiler can properly pack the <code>enum</code> type wasting no bytes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub enum </span>Packed {
    A(intx::U24), <span class="comment">// Now using a type that reflects our usage intent properly.
    </span>B(i16),
}
<span class="macro">assert_eq!</span>(core::mem::size_of::&lt;Packed&gt;(), <span class="number">4</span>);</code></pre></div>
<h2 id="example-alignment"><a href="#example-alignment">Example: Alignment</a></h2>
<p>With standard alignment the <code>enum</code> discriminent takes up a whopping 8 bytes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub enum </span>Aligned {
    A(u64),
    B(i64),
}
<span class="macro">assert_eq!</span>(core::mem::size_of::&lt;Aligned&gt;(), <span class="number">16</span>);</code></pre></div>
<p>Using <code>intx</code> integers with their alignment of 1 allows to pack the <code>enum</code> discrimant to a single byte.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub enum </span>Unaligned {
    A(intx::U64),
    B(intx::I64),
}
<span class="macro">assert_eq!</span>(core::mem::size_of::&lt;Unaligned&gt;(), <span class="number">9</span>);</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.I16.html" title="struct intx::I16">I16</a></div><div class="desc docblock-short">16-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I24.html" title="struct intx::I24">I24</a></div><div class="desc docblock-short">24-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I32.html" title="struct intx::I32">I32</a></div><div class="desc docblock-short">32-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I40.html" title="struct intx::I40">I40</a></div><div class="desc docblock-short">40-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I48.html" title="struct intx::I48">I48</a></div><div class="desc docblock-short">48-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I56.html" title="struct intx::I56">I56</a></div><div class="desc docblock-short">56-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I64.html" title="struct intx::I64">I64</a></div><div class="desc docblock-short">64-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I72.html" title="struct intx::I72">I72</a></div><div class="desc docblock-short">72-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I80.html" title="struct intx::I80">I80</a></div><div class="desc docblock-short">80-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I88.html" title="struct intx::I88">I88</a></div><div class="desc docblock-short">88-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I96.html" title="struct intx::I96">I96</a></div><div class="desc docblock-short">96-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I104.html" title="struct intx::I104">I104</a></div><div class="desc docblock-short">104-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I112.html" title="struct intx::I112">I112</a></div><div class="desc docblock-short">112-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I120.html" title="struct intx::I120">I120</a></div><div class="desc docblock-short">120-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.I128.html" title="struct intx::I128">I128</a></div><div class="desc docblock-short">128-bit signed integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.TryFromIntError.html" title="struct intx::TryFromIntError">TryFromIntError</a></div><div class="desc docblock-short">Error that may occur for fallible conversions between integers.</div></li><li><div class="item-name"><a class="struct" href="struct.U16.html" title="struct intx::U16">U16</a></div><div class="desc docblock-short">16-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U24.html" title="struct intx::U24">U24</a></div><div class="desc docblock-short">24-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U32.html" title="struct intx::U32">U32</a></div><div class="desc docblock-short">32-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U40.html" title="struct intx::U40">U40</a></div><div class="desc docblock-short">40-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U48.html" title="struct intx::U48">U48</a></div><div class="desc docblock-short">48-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U56.html" title="struct intx::U56">U56</a></div><div class="desc docblock-short">56-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U64.html" title="struct intx::U64">U64</a></div><div class="desc docblock-short">64-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U72.html" title="struct intx::U72">U72</a></div><div class="desc docblock-short">72-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U80.html" title="struct intx::U80">U80</a></div><div class="desc docblock-short">80-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U88.html" title="struct intx::U88">U88</a></div><div class="desc docblock-short">88-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U96.html" title="struct intx::U96">U96</a></div><div class="desc docblock-short">96-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U104.html" title="struct intx::U104">U104</a></div><div class="desc docblock-short">104-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U112.html" title="struct intx::U112">U112</a></div><div class="desc docblock-short">112-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U120.html" title="struct intx::U120">U120</a></div><div class="desc docblock-short">120-bit unsigned integer with alignment of 1.</div></li><li><div class="item-name"><a class="struct" href="struct.U128.html" title="struct intx::U128">U128</a></div><div class="desc docblock-short">128-bit unsigned integer with alignment of 1.</div></li></ul></section></div></main></body></html>