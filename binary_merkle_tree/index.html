<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate implements a simple binary Merkle Tree utilities required for inter-op with Ethereum bridge &#38; Solidity contract."><title>binary_merkle_tree - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="binary_merkle_tree" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate binary_merkle_tree</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../binary_merkle_tree/index.html">binary_<wbr>merkle_<wbr>tree</a><span class="version">13.0.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>binary_<wbr>merkle_<wbr>tree</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/binary_merkle_tree/lib.rs.html#18-801">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate implements a simple binary Merkle Tree utilities required for inter-op with Ethereum
bridge &amp; Solidity contract.</p>
<p>The implementation is optimised for usage within Substrate Runtime and supports no-std
compilation targets.</p>
<p>Merkle Tree is constructed from arbitrary-length leaves, that are initially hashed using the
same hasher as the inner nodes.
Inner nodes are created by concatenating child hashes and hashing again. The implementation
does not perform any sorting of the input data (leaves) nor when inner nodes are created.</p>
<p>If the number of leaves is not even, last leaf (hash of) is promoted to the upper layer.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.MerkleProof.html" title="struct binary_merkle_tree::MerkleProof">Merkle<wbr>Proof</a></dt><dd>A generated merkle proof.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Leaf.html" title="enum binary_merkle_tree::Leaf">Leaf</a></dt><dd>Leaf node for proof verification.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="fn" href="fn.merkle_proof.html" title="fn binary_merkle_tree::merkle_proof">merkle_<wbr>proof</a></dt><dd>Construct a Merkle Proof for leaves given by indices.</dd><dt><a class="fn" href="fn.merkle_root.html" title="fn binary_merkle_tree::merkle_root">merkle_<wbr>root</a></dt><dd>Construct a root hash of a Binary Merkle Tree created from given leaves.</dd><dt><a class="fn" href="fn.verify_proof.html" title="fn binary_merkle_tree::verify_proof">verify_<wbr>proof</a></dt><dd>Verify Merkle Proof correctness versus given root hash.</dd></dl></section></div></main></body></html>