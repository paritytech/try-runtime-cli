<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Try-runtime"><title>try_runtime - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="try_runtime" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate try_runtime</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../try_runtime/index.html">try_<wbr>runtime</a><span class="version">0.8.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#try-runtime" title="Try-runtime">Try-runtime</a><ul><li><a href="#resources" title="Resources">Resources</a></li><li><a href="#background-knowledge" title="Background Knowledge">Background Knowledge</a></li><li><a href="#installation" title="Installation">Installation</a></li><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#spec-name-check" title="Spec name check">Spec name check</a></li><li><a href="#note-on-signature-and-state-root-checks" title="Note on signature and state-root checks">Note on signature and state-root checks</a></li><li><a href="#best-practices" title="Best Practices">Best Practices</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#functions">Crate Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>try_<wbr>runtime</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/try_runtime/main.rs.html#18-327">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="try-runtime"><a class="doc-anchor" href="#try-runtime">Â§</a>Try-runtime</h2>
<p>Substrateâ€™s programmatic testing framework.</p>
<blockquote>
<p>As the name suggests, <code>try-runtime</code> is a detailed testing framework that gives you a lot of
control over what is being executed in which environment. It is recommended that userâ€™s first
familiarize themselves with substrate in depth, particularly the execution model. It is
critical
to deeply understand how the wasm/client/runtime interactions, and the runtime apis work in
the
substrate runtime, before commencing to working with <code>try-runtime</code>.</p>
</blockquote>
<h5 id="resources"><a class="doc-anchor" href="#resources">Â§</a>Resources</h5>
<p>Some resources about the above:</p>
<ol>
<li><a href="https://www.crowdcast.io/e/substrate-seminar/41">https://www.crowdcast.io/e/substrate-seminar/41</a></li>
<li><a href="https://docs.substrate.io/fundamentals/runtime-development/">https://docs.substrate.io/fundamentals/runtime-development/</a></li>
<li><a href="https://www.youtube.com/watch?v=a_u3KMG-n-I">https://www.youtube.com/watch?v=a_u3KMG-n-I</a></li>
</ol>
<hr />
<h3 id="background-knowledge"><a class="doc-anchor" href="#background-knowledge">Â§</a>Background Knowledge</h3>
<p>The basis of all try-runtime commands is the same: connect to a live node, scrape its <em>state</em>
and put it inside a <a href="../sp_state_machine/testing/struct.TestExternalities.html" title="struct sp_state_machine::testing::TestExternalities"><code>TestExternalities</code></a>, then call into a <em>specific runtime-api</em> using the
given state and some <em>runtime</em>.</p>
<p>Alternatively, the state could come from a snapshot file.</p>
<p>All of the variables in the above statement are made <em>italic</em>. Letâ€™s look at each of them:</p>
<ol>
<li>
<p><strong>State</strong> is the key-value pairs of data that comprise the canonical information that any
blockchain is keeping. A state can be full (all key-value pairs), or be partial (only pairs
related to some pallets/prefixes). Moreover, some keys are special and are not related to
specific pallets, known as <a href="../sp_storage/well_known_keys/index.html" title="mod sp_storage::well_known_keys"><code>well_known_keys</code></a> in substrate. The most important of these is
the <code>:CODE:</code> key, which contains the code used for execution, when wasm execution is chosen.</p>
</li>
<li>
<p><em>A runtime-api</em> call is a call into a function defined in the runtime, <em>on top of a given
state</em>. Each subcommand of <code>try-runtime</code> utilizes a specific <em>runtime-api</em>.</p>
</li>
<li>
<p>Finally, the <strong>runtime</strong> is the actual code that is used to execute the aforementioned
runtime-api. Everything in this crate assumes wasm execution, which means the runtime that
you use is the one stored onchain, namely under the <code>:CODE:</code> key.</p>
</li>
</ol>
<p>To recap, a typical try-runtime command does the following:</p>
<ol>
<li>Download the state of a live chain, and write to an <code>externalities</code>.</li>
<li>Overwrite the <code>:CODE:</code> with a given wasm blob</li>
<li>Test some functionality via calling a runtime-api.</li>
</ol>
<h3 id="installation"><a class="doc-anchor" href="#installation">Â§</a>Installation</h3><div class="example-wrap"><pre class="language-bash"><code> # Install latest version (recommended for local development)
 cargo install --git https://github.com/paritytech/try-runtime-cli --locked
 # Install a specific version (recommended for tools like CI)
 cargo install --git https://github.com/paritytech/try-runtime-cli --tag vX.Y.Z --locked
 try-runtime --help
 try-runtime on-runtime-upgrade --help</code></pre></div><h3 id="usage"><a class="doc-anchor" href="#usage">Â§</a>Usage</h3>
<p>To use any of the provided commands, <a href="try_runtime_core::shared_parameters::SharedParams"><code>SharedParams</code></a> must be provided. The most important of
which being <a href="../try_runtime_core/common/shared_parameters/struct.SharedParams.html#structfield.runtime" title="field try_runtime_core::common::shared_parameters::SharedParams::runtime"><code>SharedParams::runtime</code></a>, which specifies which runtime to use. Furthermore,
<a href="../try_runtime_core/common/shared_parameters/struct.SharedParams.html#structfield.overwrite_state_version" title="field try_runtime_core::common::shared_parameters::SharedParams::overwrite_state_version"><code>SharedParams::overwrite_state_version</code></a> can be used to alter the state-version (see
<a href="https://forum.polkadot.network/t/state-trie-migration/852">https://forum.polkadot.network/t/state-trie-migration/852</a> for more info).</p>
<p>Then, the specific command has to be specified. See <a href="../try_runtime_core/commands/enum.Action.html" title="enum try_runtime_core::commands::Action"><code>Action</code></a> for more information about each
commandâ€™s specific customization flags, and assumptions regarding the runtime being used.</p>
<p>Briefly, this CLI is capable of executing:</p>
<ul>
<li><a href="../try_runtime_core/commands/enum.Action.html#variant.OnRuntimeUpgrade" title="variant try_runtime_core::commands::Action::OnRuntimeUpgrade"><code>Action::OnRuntimeUpgrade</code></a>: execute all the <a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html" title="trait frame_support::traits::hooks::OnRuntimeUpgrade"><code>OnRuntimeUpgrade</code></a> hooks.</li>
<li><a href="../try_runtime_core/commands/enum.Action.html#variant.ExecuteBlock" title="variant try_runtime_core::commands::Action::ExecuteBlock"><code>Action::ExecuteBlock</code></a>: re-execute the given block.</li>
<li><a href="../try_runtime_core/commands/enum.Action.html#variant.FastForward" title="variant try_runtime_core::commands::Action::FastForward"><code>Action::FastForward</code></a>: execute <a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html" title="trait frame_support::traits::hooks::OnRuntimeUpgrade"><code>OnRuntimeUpgrade</code></a> hooks, then fast-forward the chain a
given number of blocks while checking try-state invarients.</li>
<li><a href="../try_runtime_core/commands/enum.Action.html#variant.OffchainWorker" title="variant try_runtime_core::commands::Action::OffchainWorker"><code>Action::OffchainWorker</code></a>: re-execute the given blockâ€™s offchain worker code path.</li>
<li><a href="../try_runtime_core/commands/enum.Action.html#variant.FollowChain" title="variant try_runtime_core::commands::Action::FollowChain"><code>Action::FollowChain</code></a>: continuously execute the blocks of a remote chain on top of a given
runtime.</li>
<li><a href="../try_runtime_core/commands/enum.Action.html#variant.CreateSnapshot" title="variant try_runtime_core::commands::Action::CreateSnapshot"><code>Action::CreateSnapshot</code></a>: Create a snapshot file from a remote node.</li>
</ul>
<p>Finally, to make sure there are no errors regarding this, always run any <code>try-runtime</code> command
with <code>executor=trace</code> logging targets, which will specify which runtime is being used per api
call. Moreover, <code>remote-ext</code>, <code>try-runtime</code> and <code>runtime</code> logs targets will also be useful.</p>
<h3 id="spec-name-check"><a class="doc-anchor" href="#spec-name-check">Â§</a>Spec name check</h3>
<p>A common pitfall is that you might be running some test on top of the state of chain <code>x</code>, with
the runtime of chain <code>y</code>. To avoid this all commands do a spec-name check before executing
anything by default. This will check the, if any alterations are being made to the <code>:CODE:</code>,
then the spec names match. The spec versions are warned, but are not mandated to match.</p>
<blockquote>
<p>If anything, in most cases, we expect spec-versions to NOT match, because try-runtime is all
about testing unreleased runtimes.</p>
</blockquote>
<h3 id="note-on-signature-and-state-root-checks"><a class="doc-anchor" href="#note-on-signature-and-state-root-checks">Â§</a>Note on signature and state-root checks</h3>
<p>All of the commands calling into <code>TryRuntime_execute_block</code> (<a href="../try_runtime_core/commands/enum.Action.html#variant.ExecuteBlock" title="variant try_runtime_core::commands::Action::ExecuteBlock"><code>Action::ExecuteBlock</code></a> and
<a href="../try_runtime_core/commands/enum.Action.html#variant.FollowChain" title="variant try_runtime_core::commands::Action::FollowChain"><code>Action::FollowChain</code></a>) disable both state root and signature checks. This is because in 99%
of the cases, the runtime that is being tested is different from the one that is stored in the
canonical chain state. This implies:</p>
<ol>
<li>the state root will NEVER match, because <code>:CODE:</code> is different between the two.</li>
<li>replaying all transactions will fail, because the spec-version is part of the transaction
signature.</li>
</ol>
<h3 id="best-practices"><a class="doc-anchor" href="#best-practices">Â§</a>Best Practices</h3>
<p>Try-runtime is all about battle-testing unreleased runtimes. The following list of suggestions
help developers maximize their testing coverage and make the best use of <code>try-runtime</code> features.</p>
<h4 id="testing-runtime-upgrades"><a class="doc-anchor" href="#testing-runtime-upgrades">Â§</a>Testing Runtime Upgrades</h4>
<p>One of the most powerful abilities of <code>try-runtime</code> is using the
<a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html#method.pre_upgrade" title="associated function frame_support::traits::hooks::OnRuntimeUpgrade::pre_upgrade"><code>OnRuntimeUpgrade::pre_upgrade</code></a> and <a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html#method.post_upgrade" title="associated function frame_support::traits::hooks::OnRuntimeUpgrade::post_upgrade"><code>OnRuntimeUpgrade::post_upgrade</code></a> hooks to test runtime
upgrades implemented with <a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html" title="trait frame_support::traits::hooks::OnRuntimeUpgrade"><code>OnRuntimeUpgrade</code></a>. <a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html" title="trait frame_support::traits::hooks::OnRuntimeUpgrade"><code>OnRuntimeUpgrade</code></a> can be implemented inside
the pallet, or standalone in a runtime to define a migration to execute next runtime upgrade. In
both cases, these methods can be added:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="string">"try-runtime"</span>)]
</span><span class="kw">fn </span>pre_upgrade() -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, TryRuntimeError&gt; {}

<span class="attr">#[cfg(feature = <span class="string">"try-runtime"</span>)]
</span><span class="kw">fn </span>post_upgrade(state: Vec&lt;u8&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;(), TryRuntimeError&gt; {}</code></pre></div>
<p>(The pallet macro syntax will support this simply as a part of <code>#[pallet::hooks]</code>).</p>
<p>These hooks will be called when you execute the <a href="../try_runtime_core/commands/enum.Action.html#variant.OnRuntimeUpgrade" title="variant try_runtime_core::commands::Action::OnRuntimeUpgrade"><code>Action::OnRuntimeUpgrade</code></a> command, before and
after the migration. <a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html#method.pre_upgrade" title="associated function frame_support::traits::hooks::OnRuntimeUpgrade::pre_upgrade"><code>OnRuntimeUpgrade::pre_upgrade</code></a> returns a <a href="https://doc.rust-lang.org/1.91.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;u8&gt;</code></a> that can contain
arbitrary encoded data (usually some pre-upgrade state) which will be passed to
<a href="../frame_support/traits/hooks/trait.OnRuntimeUpgrade.html#method.pre_upgrade" title="associated function frame_support::traits::hooks::OnRuntimeUpgrade::pre_upgrade"><code>OnRuntimeUpgrade::pre_upgrade</code></a> after upgrading and used for post checking.</p>
<h4 id="versionedmigration"><a class="doc-anchor" href="#versionedmigration">Â§</a><a href="../frame_support/migrations/struct.VersionedMigration.html" title="struct frame_support::migrations::VersionedMigration"><code>VersionedMigration</code></a></h4>
<p>It is strongly suggested to use <a href="../frame_support/migrations/struct.VersionedMigration.html" title="struct frame_support::migrations::VersionedMigration"><code>VersionedMigration</code></a> when writing custom migrations for
pallets.</p>
<h4 id="state-consistency"><a class="doc-anchor" href="#state-consistency">Â§</a>State Consistency</h4>
<p>Similarly, each pallet can expose a function in <code>#[pallet::hooks]</code> section as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(feature = <span class="string">"try-runtime"</span>)]
</span><span class="kw">fn </span>try_state(<span class="kw">_</span>: BlockNumber) -&gt; <span class="prelude-ty">Result</span>&lt;(), TryRuntimeError&gt; {}</code></pre></div>
<p>which is called on numerous code paths in the try-runtime tool. These checks should ensure that
the state of the pallet is consistent and correct. See <a href="../frame_support/traits/try_runtime/trait.TryState.html" title="trait frame_support::traits::try_runtime::TryState"><code>TryState</code></a> for more info.</p>
<h4 id="logging"><a class="doc-anchor" href="#logging">Â§</a>Logging</h4>
<p>It is super helpful to make sure your migration code uses logging (always with a <code>runtime</code> log
target prefix, e.g. <code>runtime::balance</code>) and state exactly at which stage it is, and what it is
doing.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h3>
<p>For the following examples, we assume the existence of the following:</p>
<ol>
<li>a substrate node compiled with <code>--features try-runtime</code>, called <code>substrate</code>. This will be the
running node that you connect to, and provide a wasm blob that has try-runtime functionality
enabled.</li>
<li>the <code>try-runtime</code> CLI binary on your path.</li>
</ol>
<div class="example-wrap"><pre class="language-bash"><code># this is like your running deployed node.
cargo build --features try-runtime --release &amp;&amp; cp target/release/substrate .</code></pre></div>
<blockquote>
<p>The above example is with <code>substrate</code>â€™s <code>kitchensink-runtime</code>, but is applicable to any
substrate-based chain.</p>
</blockquote>
<ul>
<li>Run the migrations of a given runtime on top of a live state.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code># assuming there&#39;s `./substrate --dev --tmp --ws-port 9999` or similar running.
try-runtime \
    --runtime /path-to-substrate/target/release/wbuild/my-runtime.wasm \
    on-runtime-upgrade \
    live --uri ws://localhost:9999</code></pre></div>
<ul>
<li>Same as the previous example, but run it at specific block numberâ€™s state and using the live
polkadot network. This means that this block hashâ€™s state should not yet have been pruned by
the node running at <code>rpc.polkadot.io</code>.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime \
    --runtime /path-to-polkadot-runtimes/target/release/wbuild/polkadot-runtime/polkadot-runtime.wasm \
    on-runtime-upgrade \
    live --uri wss://rpc.polkadot.io:443 \
    # replace with your desired block hash!
    --at 0xa1b16c1efd889a9f17375ec4dd5c1b4351a2be17fa069564fced10d23b9b3836</code></pre></div>
<ul>
<li>Now, letâ€™s use a snapshot file. First, we create the snapshot:</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime --runtime existing create-snapshot --uri ws://localhost:9999 my-snapshot.snap
2022-12-13 10:28:17.516  INFO                 main remote-ext: since no at is provided, setting it to latest finalized head, 0xe7d0b614dfe89af65b33577aae46a6f958c974bf52f8a5e865a0f4faeb578d22
2022-12-13 10:28:17.516  INFO                 main remote-ext: since no prefix is filtered, the data for all pallets will be downloaded
2022-12-13 10:28:17.550  INFO                 main remote-ext: writing snapshot of 1611464 bytes to &quot;node-268@latest.snap&quot;
2022-12-13 10:28:17.551  INFO                 main remote-ext: initialized state externalities with storage root 0x925e4e95de4c08474fb7f976c4472fa9b8a1091619cd7820a793bf796ee6d932 and state_version V1</code></pre></div>
<blockquote>
<p>Note that the snapshot contains the <code>existing</code> runtime, which does not have the correct
<code>try-runtime</code> feature. In the following commands, we still need to overwrite the runtime.</p>
</blockquote>
<p>Then, we can use it to have the same command as before, <code>on-runtime-upgrade</code></p>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime \
    --runtime /path-to-substrate/target/release/wbuild/my-runtime.wasm \
    on-runtime-upgrade \
    snap -p my-snapshot.snap</code></pre></div>
<ul>
<li>Execute the latest finalized block with the given runtime.</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime \
    --runtime /path-to-substrate/target/release/wbuild/my-runtime.wasm \
    execute-block live \
    --uri ws://localhost:9999</code></pre></div>
<p>This can still be customized at a given block with <code>--at</code>. If you want to use a snapshot, you
can still use <code>--block-ws-uri</code> to provide a node form which the block data can be fetched.</p>
<p>Moreover, this runs the <a href="../frame_support/traits/try_runtime/trait.TryState.html" title="trait frame_support::traits::try_runtime::TryState"><code>TryState</code></a> hooks as well. The hooks to run can be customized with the
<code>--try-state</code>. For example:</p>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime \
    --runtime /path-to-substrate/target/release/wbuild/my-runtime.wasm \
   execute-block \
   --try-state System,Staking \
   live \
   --uri ws://localhost:9999 \
   --pallet System Staking</code></pre></div>
<p>Will only run the <code>try-state</code> of the two given pallets. When running <code>try-state</code> against
some real chain data it can take a long time for the command to execute since it has to
query all the key-value pairs. In scenarios like above where we only want to run the
<code>try-state</code> for some specific pallets, we can use the <code>--pallet</code> option to specify from
which pallets we want to query the state. This will greatly decrease the execution time.</p>
<p>See <a href="../frame_support/traits/try_runtime/enum.Select.html" title="enum frame_support::traits::try_runtime::Select"><code>TryStateSelect</code></a> for more information.</p>
<ul>
<li>Follow our live chainâ€™s blocks using <code>follow-chain</code>, whilst running the try-state of 3 pallets
in a round robin fashion</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>try-runtime \
    --runtime /path-to-substrate/target/release/wbuild/my-runtime.wasm \
    follow-chain \
    --uri ws://localhost:9999 \
    --try-state rr-3</code></pre></div></div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.init_env.html" title="fn try_runtime::init_env">init_<wbr>env</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="fn" href="fn.main.html" title="fn try_runtime::main">main</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl></section></div></main></body></html>