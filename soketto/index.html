<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An implementation of the RFC 6455 websocket protocol."><title>soketto - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="soketto" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../soketto/index.html">soketto</a><span class="version">0.7.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">soketto</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/soketto/lib.rs.html#10-189">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An implementation of the <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a> websocket protocol.</p>
<p>To begin a websocket connection one first needs to perform a <a href="https://tools.ietf.org/html/rfc6455#section-4">handshake</a>,
either as <a href="handshake/client/struct.Client.html" title="struct soketto::handshake::client::Client">client</a> or <a href="handshake/server/struct.Server.html" title="struct soketto::handshake::server::Server">server</a>, in order to upgrade from HTTP.
Once successful, the client or server can transition to a connection,
i.e. a <a href="connection/struct.Sender.html" title="struct soketto::connection::Sender">Sender</a>/<a href="connection/struct.Receiver.html" title="struct soketto::connection::Receiver">Receiver</a> pair and send and receive textual or
binary data.</p>
<p><strong>Note</strong>: While it is possible to only receive websocket messages it is
not possible to only send websocket messages. Receiving data is required
in order to react to control frames such as PING or CLOSE. While those will be
answered transparently they have to be received in the first place, so
calling <a href="connection/struct.Receiver.html#method.receive" title="method soketto::connection::Receiver::receive"><code>connection::Receiver::receive</code></a> is imperative.</p>
<p><strong>Note</strong>: None of the <code>async</code> methods are safe to cancel so their <code>Future</code>s
must not be dropped unless they return <code>Poll::Ready</code>.</p>
<h2 id="client-example"><a class="doc-anchor" href="#client-example">§</a>Client example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>soketto::handshake::{Client, ServerResponse};

<span class="comment">// First, we need to establish a TCP connection.
</span><span class="kw">let </span>socket = tokio::net::TcpStream::connect(<span class="string">"..."</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// Then we configure the client handshake.
</span><span class="kw">let </span><span class="kw-2">mut </span>client = Client::new(socket.compat(), <span class="string">"..."</span>, <span class="string">"/"</span>);

<span class="comment">// And finally we perform the handshake and handle the result.
</span><span class="kw">let </span>(<span class="kw-2">mut </span>sender, <span class="kw-2">mut </span>receiver) = <span class="kw">match </span>client.handshake().<span class="kw">await</span><span class="question-mark">? </span>{
    ServerResponse::Accepted { .. } =&gt; client.into_builder().finish(),
    ServerResponse::Redirect { status_code, location } =&gt; <span class="macro">unimplemented!</span>(<span class="string">"follow location URL"</span>),
    ServerResponse::Rejected { status_code } =&gt; <span class="macro">unimplemented!</span>(<span class="string">"handle failure"</span>)
};

<span class="comment">// Over the established websocket connection we can send
</span>sender.send_text(<span class="string">"some text"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
sender.send_text(<span class="string">"some more text"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
sender.flush().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// ... and receive data.
</span><span class="kw">let </span><span class="kw-2">mut </span>data = Vec::new();
receiver.receive_data(<span class="kw-2">&amp;mut </span>data).<span class="kw">await</span><span class="question-mark">?</span>;

</code></pre></div>
<h2 id="server-example"><a class="doc-anchor" href="#server-example">§</a>Server example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>soketto::{handshake::{Server, ClientRequest, server::Response}};

<span class="comment">// First, we listen for incoming connections.
</span><span class="kw">let </span>listener = tokio::net::TcpListener::bind(<span class="string">"..."</span>).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>incoming = TcpListenerStream::new(listener);

<span class="kw">while let </span><span class="prelude-val">Some</span>(socket) = incoming.next().<span class="kw">await </span>{
    <span class="comment">// For each incoming connection we perform a handshake.
    </span><span class="kw">let </span><span class="kw-2">mut </span>server = Server::new(socket<span class="question-mark">?</span>.compat());

    <span class="kw">let </span>websocket_key = {
        <span class="kw">let </span>req = server.receive_request().<span class="kw">await</span><span class="question-mark">?</span>;
        req.key()
    };

    <span class="comment">// Here we accept the client unconditionally.
    </span><span class="kw">let </span>accept = Response::Accept { key: websocket_key, protocol: <span class="prelude-val">None </span>};
    server.send_response(<span class="kw-2">&amp;</span>accept).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="comment">// And we can finally transition to a websocket connection.
    </span><span class="kw">let </span>(<span class="kw-2">mut </span>sender, <span class="kw-2">mut </span>receiver) = server.into_builder().finish();

    <span class="kw">let </span><span class="kw-2">mut </span>data = Vec::new();
    <span class="kw">let </span>data_type = receiver.receive_data(<span class="kw-2">&amp;mut </span>data).<span class="kw">await</span><span class="question-mark">?</span>;

    <span class="kw">if </span>data_type.is_text() {
        sender.send_text(std::str::from_utf8(<span class="kw-2">&amp;</span>data)<span class="question-mark">?</span>).<span class="kw">await</span><span class="question-mark">?
    </span>} <span class="kw">else </span>{
        sender.send_binary(<span class="kw-2">&amp;</span>data).<span class="kw">await</span><span class="question-mark">?
    </span>}

    sender.close().<span class="kw">await</span><span class="question-mark">?
</span>}

</code></pre></div>
<p>See <code>examples/hyper_server.rs</code> from this crate’s repository for an example of
starting up a WebSocket server alongside an Hyper HTTP server.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Mode"><code>pub use connection::<a class="enum" href="connection/enum.Mode.html" title="enum soketto::connection::Mode">Mode</a>;</code></div></li><li><div class="item-name" id="reexport.Receiver"><code>pub use connection::<a class="struct" href="connection/struct.Receiver.html" title="struct soketto::connection::Receiver">Receiver</a>;</code></div></li><li><div class="item-name" id="reexport.Sender"><code>pub use connection::<a class="struct" href="connection/struct.Sender.html" title="struct soketto::connection::Sender">Sender</a>;</code></div></li><li><div class="item-name" id="reexport.Data"><code>pub use data::<a class="enum" href="data/enum.Data.html" title="enum soketto::data::Data">Data</a>;</code></div></li><li><div class="item-name" id="reexport.Incoming"><code>pub use data::<a class="enum" href="data/enum.Incoming.html" title="enum soketto::data::Incoming">Incoming</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="base/index.html" title="mod soketto::base">base</a></div><div class="desc docblock-short">A websocket <a href="https://tools.ietf.org/html/rfc6455#section-5.2">base frame</a> codec.</div></li><li><div class="item-name"><a class="mod" href="connection/index.html" title="mod soketto::connection">connection</a></div><div class="desc docblock-short">A persistent websocket connection after the handshake phase, represented
as a <a href="connection/struct.Sender.html" title="struct soketto::connection::Sender"><code>Sender</code></a> and <a href="connection/struct.Receiver.html" title="struct soketto::connection::Receiver"><code>Receiver</code></a> pair.</div></li><li><div class="item-name"><a class="mod" href="data/index.html" title="mod soketto::data">data</a></div><div class="desc docblock-short">Types describing various forms of payload data.</div></li><li><div class="item-name"><a class="mod" href="extension/index.html" title="mod soketto::extension">extension</a></div><div class="desc docblock-short">Websocket extensions as per <a href="https://tools.ietf.org/html/rfc6455#section-9">RFC 6455</a>.</div></li><li><div class="item-name"><a class="mod" href="handshake/index.html" title="mod soketto::handshake">handshake</a></div><div class="desc docblock-short">Websocket <a href="https://tools.ietf.org/html/rfc6455#section-4">handshake</a>s.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Parsing.html" title="enum soketto::Parsing">Parsing</a></div><div class="desc docblock-short">A parsing result.</div></li><li><div class="item-name"><a class="enum" href="enum.Storage.html" title="enum soketto::Storage">Storage</a></div><div class="desc docblock-short">A buffer type used for implementing <code>Extension</code>s.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.BoxedError.html" title="type soketto::BoxedError">BoxedError</a></div></li></ul></section></div></main></body></html>