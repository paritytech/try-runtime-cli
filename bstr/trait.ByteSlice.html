<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait that extends `&amp;[u8]` with string oriented methods."><title>ByteSlice in bstr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bstr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bstr/index.html">bstr</a><span class="version">0.2.17</span></h2></div><h2 class="location"><a href="#">ByteSlice</a></h2><div class="sidebar-elems"><section><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.as_bstr">as_bstr</a></li><li><a href="#method.as_bstr_mut">as_bstr_mut</a></li><li><a href="#method.bytes">bytes</a></li><li><a href="#method.char_indices">char_indices</a></li><li><a href="#method.chars">chars</a></li><li><a href="#method.contains_str">contains_str</a></li><li><a href="#method.copy_within_str">copy_within_str</a></li><li><a href="#method.ends_with_str">ends_with_str</a></li><li><a href="#method.fields">fields</a></li><li><a href="#method.fields_with">fields_with</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_byte">find_byte</a></li><li><a href="#method.find_byteset">find_byteset</a></li><li><a href="#method.find_char">find_char</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.find_non_ascii_byte">find_non_ascii_byte</a></li><li><a href="#method.find_not_byteset">find_not_byteset</a></li><li><a href="#method.grapheme_indices">grapheme_indices</a></li><li><a href="#method.graphemes">graphemes</a></li><li><a href="#method.is_ascii">is_ascii</a></li><li><a href="#method.is_utf8">is_utf8</a></li><li><a href="#method.last_byte">last_byte</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.lines_with_terminator">lines_with_terminator</a></li><li><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a></li><li><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a></li><li><a href="#method.reverse_bytes">reverse_bytes</a></li><li><a href="#method.reverse_chars">reverse_chars</a></li><li><a href="#method.reverse_graphemes">reverse_graphemes</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rfind_byte">rfind_byte</a></li><li><a href="#method.rfind_byteset">rfind_byteset</a></li><li><a href="#method.rfind_char">rfind_char</a></li><li><a href="#method.rfind_iter">rfind_iter</a></li><li><a href="#method.rfind_not_byteset">rfind_not_byteset</a></li><li><a href="#method.rsplit_str">rsplit_str</a></li><li><a href="#method.rsplitn_str">rsplitn_str</a></li><li><a href="#method.sentence_indices">sentence_indices</a></li><li><a href="#method.sentences">sentences</a></li><li><a href="#method.split_str">split_str</a></li><li><a href="#method.splitn_str">splitn_str</a></li><li><a href="#method.starts_with_str">starts_with_str</a></li><li><a href="#method.to_str">to_str</a></li><li><a href="#method.to_str_unchecked">to_str_unchecked</a></li><li><a href="#method.trim">trim</a></li><li><a href="#method.trim_end">trim_end</a></li><li><a href="#method.trim_end_with">trim_end_with</a></li><li><a href="#method.trim_start">trim_start</a></li><li><a href="#method.trim_start_with">trim_start_with</a></li><li><a href="#method.trim_with">trim_with</a></li><li><a href="#method.utf8_chunks">utf8_chunks</a></li><li><a href="#method.word_indices">word_indices</a></li><li><a href="#method.words">words</a></li><li><a href="#method.words_with_break_indices">words_with_break_indices</a></li><li><a href="#method.words_with_breaks">words_with_breaks</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-ByteSlice-for-%5Bu8%5D">[u8]</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In crate bstr</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">bstr</a>::<wbr><a class="trait" href="#">ByteSlice</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/bstr/ext_slice.rs.html#92-2969">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait ByteSlice: Sealed {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 55 methods</span></summary>    // Provided methods
    fn <a href="#method.as_bstr" class="fn">as_bstr</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.as_bstr_mut" class="fn">as_bstr_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.to_str" class="fn">to_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt; { ... }
<span class="item-spacer"></span>    unsafe fn <a href="#method.to_str_unchecked" class="fn">to_str_unchecked</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.contains_str" class="fn">contains_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.starts_with_str" class="fn">starts_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, prefix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.ends_with_str" class="fn">ends_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, suffix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.find" class="fn">find</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind" class="fn">rfind</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        needle: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
    ) -&gt; <a class="struct" href="struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="Find&lt;&#39;a&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_iter" class="fn">rfind_iter</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        needle: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
    ) -&gt; <a class="struct" href="struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="FindReverse&lt;&#39;a&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_byte" class="fn">find_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_byte" class="fn">rfind_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_char" class="fn">find_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_char" class="fn">rfind_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_byteset" class="fn">find_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_not_byteset" class="fn">find_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_byteset" class="fn">rfind_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_not_byteset" class="fn">rfind_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.fields" class="fn">fields</a>(&amp;self) -&gt; <a class="struct" href="struct.Fields.html" title="struct bstr::Fields">Fields</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Fields&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.fields_with" class="fn">fields_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, f: F) -&gt; <a class="struct" href="struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'_, F&gt; <a href="#" class="tooltip" data-notable-ty="FieldsWith&lt;&#39;_, F&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.split_str" class="fn">split_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
    ) -&gt; <a class="struct" href="struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;a&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.rsplit_str" class="fn">rsplit_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
    ) -&gt; <a class="struct" href="struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="SplitReverse&lt;&#39;a&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.splitn_str" class="fn">splitn_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        limit: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
    ) -&gt; <a class="struct" href="struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;a&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.rsplitn_str" class="fn">rsplitn_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
        &amp;'a self,
        limit: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
        splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
    ) -&gt; <a class="struct" href="struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="SplitNReverse&lt;&#39;a&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.utf8_chunks" class="fn">utf8_chunks</a>(&amp;self) -&gt; <a class="struct" href="struct.Utf8Chunks.html" title="struct bstr::Utf8Chunks">Utf8Chunks</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Utf8Chunks&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.graphemes" class="fn">graphemes</a>(&amp;self) -&gt; <a class="struct" href="struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Graphemes&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.grapheme_indices" class="fn">grapheme_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="GraphemeIndices&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.words" class="fn">words</a>(&amp;self) -&gt; <a class="struct" href="struct.Words.html" title="struct bstr::Words">Words</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Words&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.word_indices" class="fn">word_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="WordIndices&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.words_with_breaks" class="fn">words_with_breaks</a>(&amp;self) -&gt; <a class="struct" href="struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="WordsWithBreaks&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.words_with_break_indices" class="fn">words_with_break_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="WordsWithBreakIndices&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.sentences" class="fn">sentences</a>(&amp;self) -&gt; <a class="struct" href="struct.Sentences.html" title="struct bstr::Sentences">Sentences</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Sentences&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.sentence_indices" class="fn">sentence_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SentenceIndices&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.lines_with_terminator" class="fn">lines_with_terminator</a>(&amp;self) -&gt; <a class="struct" href="struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesWithTerminator&lt;&#39;_&gt;">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_with" class="fn">trim_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_start_with" class="fn">trim_start_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.trim_end_with" class="fn">trim_end_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.reverse_bytes" class="fn">reverse_bytes</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.reverse_chars" class="fn">reverse_chars</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.reverse_graphemes" class="fn">reverse_graphemes</a>(&amp;mut self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_utf8" class="fn">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.last_byte" class="fn">last_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_non_ascii_byte" class="fn">find_non_ascii_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.copy_within_str" class="fn">copy_within_str</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)
       <span class="where">where R: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</span> { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait that extends <code>&amp;[u8]</code> with string oriented methods.</p>
</div></details><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.as_bstr" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#123-125">source</a><h4 class="code-header">fn <a href="#method.as_bstr" class="fn">as_bstr</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a></h4></section></summary><div class="docblock"><p>Return this byte slice as a <code>&amp;BStr</code>.</p>
<p>Use <code>&amp;BStr</code> is useful because of its <code>fmt::Debug</code> representation
and various other trait implementations (such as <code>PartialEq</code> and
<code>PartialOrd</code>). In particular, the <code>Debug</code> implementation for <code>BStr</code>
shows its bytes as a normal string. For invalid UTF-8, hex escape
sequences are used.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">println!</span>(<span class="string">"{:?}"</span>, <span class="string">b"foo\xFFbar"</span>.as_bstr());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bstr_mut" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#146-148">source</a><h4 class="code-header">fn <a href="#method.as_bstr_mut" class="fn">as_bstr_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.BStr.html" title="struct bstr::BStr">BStr</a></h4></section></summary><div class="docblock"><p>Return this byte slice as a <code>&amp;mut BStr</code>.</p>
<p>Use <code>&amp;mut BStr</code> is useful because of its <code>fmt::Debug</code> representation
and various other trait implementations (such as <code>PartialEq</code> and
<code>PartialOrd</code>). In particular, the <code>Debug</code> implementation for <code>BStr</code>
shows its bytes as a normal string. For invalid UTF-8, hex escape
sequences are used.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="kw-2">*</span><span class="string">b"foo\xFFbar"</span>;
<span class="macro">println!</span>(<span class="string">"{:?}"</span>, <span class="kw-2">&amp;mut </span>bytes.as_bstr_mut());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#246-252">source</a><h4 class="code-header">fn <a href="#method.to_str" class="fn">to_str</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a>, <a class="struct" href="struct.Utf8Error.html" title="struct bstr::Utf8Error">Utf8Error</a>&gt;</h4></section></summary><div class="docblock"><p>Safely convert this byte string into a <code>&amp;str</code> if it’s valid UTF-8.</p>
<p>If this byte string is not valid UTF-8, then an error is returned. The
error returned indicates the first invalid byte found and the length
of the error.</p>
<p>In cases where a lossy conversion to <code>&amp;str</code> is acceptable, then use one
of the <a href="trait.ByteSlice.html#method.to_str_lossy"><code>to_str_lossy</code></a> or
<a href="trait.ByteSlice.html#method.to_str_lossy_into"><code>to_str_lossy_into</code></a>
methods.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice, ByteVec};

<span class="kw">let </span>s = B(<span class="string">"☃βツ"</span>).to_str()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="string">"☃βツ"</span>, s);

<span class="kw">let </span><span class="kw-2">mut </span>bstring = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"☃βツ"</span>);
bstring.push(<span class="string">b'\xFF'</span>);
<span class="kw">let </span>err = bstring.to_str().unwrap_err();
<span class="macro">assert_eq!</span>(<span class="number">8</span>, err.valid_up_to());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_str_unchecked" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#281-283">source</a><h4 class="code-header">unsafe fn <a href="#method.to_str_unchecked" class="fn">to_str_unchecked</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Unsafely convert this byte string into a <code>&amp;str</code>, without checking for
valid UTF-8.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>Callers <em>must</em> ensure that this byte string is valid UTF-8 before
calling this method. Converting a byte string into a <code>&amp;str</code> that is
not valid UTF-8 is considered undefined behavior.</p>
<p>This routine is useful in performance sensitive contexts where the
UTF-8 validity of the byte string is already known and it is
undesirable to pay the cost of an additional UTF-8 validation check
that <a href="trait.ByteSlice.html#method.to_str"><code>to_str</code></a> performs.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="comment">// SAFETY: This is safe because string literals are guaranteed to be
// valid UTF-8 by the Rust compiler.
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ B(<span class="string">"☃βツ"</span>).to_str_unchecked() };
<span class="macro">assert_eq!</span>(<span class="string">"☃βツ"</span>, s);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#612-614">source</a><h4 class="code-header">fn <a href="#method.contains_str" class="fn">contains_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this byte string contains the given needle.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert!</span>(<span class="string">b"foo bar"</span>.contains_str(<span class="string">"foo"</span>));
<span class="macro">assert!</span>(<span class="string">b"foo bar"</span>.contains_str(<span class="string">"bar"</span>));
<span class="macro">assert!</span>(!<span class="string">b"foo"</span>.contains_str(<span class="string">"foobar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#630-632">source</a><h4 class="code-header">fn <a href="#method.starts_with_str" class="fn">starts_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, prefix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this byte string has the given prefix.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert!</span>(<span class="string">b"foo bar"</span>.starts_with_str(<span class="string">"foo"</span>));
<span class="macro">assert!</span>(!<span class="string">b"foo bar"</span>.starts_with_str(<span class="string">"bar"</span>));
<span class="macro">assert!</span>(!<span class="string">b"foo"</span>.starts_with_str(<span class="string">"foobar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#648-650">source</a><h4 class="code-header">fn <a href="#method.ends_with_str" class="fn">ends_with_str</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, suffix: B) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this byte string has the given suffix.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert!</span>(<span class="string">b"foo bar"</span>.ends_with_str(<span class="string">"bar"</span>));
<span class="macro">assert!</span>(!<span class="string">b"foo bar"</span>.ends_with_str(<span class="string">"foo"</span>));
<span class="macro">assert!</span>(!<span class="string">b"bar"</span>.ends_with_str(<span class="string">"foobar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#683-685">source</a><h4 class="code-header">fn <a href="#method.find" class="fn">find</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of the given needle.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>Note that if you’re are searching for the same needle in many
different small haystacks, it may be faster to initialize a
<a href="struct.Finder.html"><code>Finder</code></a> once, and reuse it for each search.</p>
<h5 id="complexity"><a class="doc-anchor" href="#complexity">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b"foo bar baz"</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), s.find(<span class="string">"foo"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), s.find(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.find(<span class="string">"quux"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#720-722">source</a><h4 class="code-header">fn <a href="#method.rfind" class="fn">rfind</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, needle: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of the given needle.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<p>Note that if you’re are searching for the same needle in many
different small haystacks, it may be faster to initialize a
<a href="struct.FinderReverse.html"><code>FinderReverse</code></a> once, and reuse it for
each search.</p>
<h5 id="complexity-1"><a class="doc-anchor" href="#complexity-1">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b"foo bar baz"</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), s.rfind(<span class="string">"foo"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), s.rfind(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), s.rfind(<span class="string">"ba"</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.rfind(<span class="string">"quux"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_iter" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#762-767">source</a><h4 class="code-header">fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;'a self, needle: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>) -&gt; <a class="struct" href="struct.Find.html" title="struct bstr::Find">Find</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="Find&lt;&#39;a&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of the non-overlapping occurrences of the given
needle. The iterator yields byte offset positions indicating the start
of each match.</p>
<h5 id="complexity-2"><a class="doc-anchor" href="#complexity-2">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b"foo bar foo foo quux foo"</span>;
<span class="kw">let </span>matches: Vec&lt;usize&gt; = s.find_iter(<span class="string">"foo"</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">21</span>]);</code></pre></div>
<p>An empty string matches at every position, including the position
immediately following the last byte:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b"foo"</span>.find_iter(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b""</span>.find_iter(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_iter" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#807-812">source</a><h4 class="code-header">fn <a href="#method.rfind_iter" class="fn">rfind_iter</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    needle: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
) -&gt; <a class="struct" href="struct.FindReverse.html" title="struct bstr::FindReverse">FindReverse</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="FindReverse&lt;&#39;a&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of the non-overlapping occurrences of the given
needle in reverse. The iterator yields byte offset positions indicating
the start of each match.</p>
<h5 id="complexity-3"><a class="doc-anchor" href="#complexity-3">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the needle and the haystack. That is, this runs
in <code>O(needle.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>s = <span class="string">b"foo bar foo foo quux foo"</span>;
<span class="kw">let </span>matches: Vec&lt;usize&gt; = s.rfind_iter(<span class="string">"foo"</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">21</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">0</span>]);</code></pre></div>
<p>An empty string matches at every position, including the position
immediately following the last byte:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b"foo"</span>.rfind_iter(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="kw">let </span>matches: Vec&lt;usize&gt; = <span class="string">b""</span>.rfind_iter(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#828-830">source</a><h4 class="code-header">fn <a href="#method.find_byte" class="fn">find_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of the given byte. If the
byte does not occur in this byte string, then <code>None</code> is returned.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b"foo bar baz"</span>.find_byte(<span class="string">b'z'</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"foo bar baz"</span>.find_byte(<span class="string">b'y'</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#846-848">source</a><h4 class="code-header">fn <a href="#method.rfind_byte" class="fn">rfind_byte</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of the given byte. If the
byte does not occur in this byte string, then <code>None</code> is returned.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b"foo bar baz"</span>.rfind_byte(<span class="string">b'z'</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"foo bar baz"</span>.rfind_byte(<span class="string">b'y'</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_char" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#870-872">source</a><h4 class="code-header">fn <a href="#method.find_char" class="fn">find_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of the given codepoint.
If the codepoint does not occur in this byte string, then <code>None</code> is
returned.</p>
<p>Note that if one searches for the replacement codepoint, <code>\u{FFFD}</code>,
then only explicit occurrences of that encoding will be found. Invalid
UTF-8 sequences will not be matched.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b"foo bar baz"</span>.find_char(<span class="string">'z'</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), B(<span class="string">"αβγγδ"</span>).find_char(<span class="string">'γ'</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"foo bar baz"</span>.find_char(<span class="string">'y'</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_char" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#894-896">source</a><h4 class="code-header">fn <a href="#method.rfind_char" class="fn">rfind_char</a>(&amp;self, ch: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of the given codepoint.
If the codepoint does not occur in this byte string, then <code>None</code> is
returned.</p>
<p>Note that if one searches for the replacement codepoint, <code>\u{FFFD}</code>,
then only explicit occurrences of that encoding will be found. Invalid
UTF-8 sequences will not be matched.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">10</span>), <span class="string">b"foo bar baz"</span>.rfind_char(<span class="string">'z'</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">6</span>), B(<span class="string">"αβγγδ"</span>).rfind_char(<span class="string">'γ'</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"foo bar baz"</span>.rfind_char(<span class="string">'y'</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#931-933">source</a><h4 class="code-header">fn <a href="#method.find_byteset" class="fn">find_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of any of the bytes in the
provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h5 id="complexity-4"><a class="doc-anchor" href="#complexity-4">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b"foo bar baz"</span>.find_byteset(<span class="string">b"zr"</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));
<span class="macro">assert_eq!</span>(<span class="string">b"foo baz bar"</span>.find_byteset(<span class="string">b"bzr"</span>), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"foo baz bar"</span>.find_byteset(<span class="string">b"\t\n"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_not_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#968-970">source</a><h4 class="code-header">fn <a href="#method.find_not_byteset" class="fn">find_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first occurrence of a byte that is not a member
of the provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h5 id="complexity-5"><a class="doc-anchor" href="#complexity-5">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b"foo bar baz"</span>.find_not_byteset(<span class="string">b"fo "</span>), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq!</span>(<span class="string">b"\t\tbaz bar"</span>.find_not_byteset(<span class="string">b" \t\r\n"</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">b"foo\nbaz\tbar"</span>.find_not_byteset(<span class="string">b"\t\n"</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1005-1007">source</a><h4 class="code-header">fn <a href="#method.rfind_byteset" class="fn">rfind_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of any of the bytes in the
provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and duplicate
bytes present in its body are ignored.</p>
<h5 id="complexity-6"><a class="doc-anchor" href="#complexity-6">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b"foo bar baz"</span>.rfind_byteset(<span class="string">b"agb"</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq!</span>(<span class="string">b"foo baz bar"</span>.rfind_byteset(<span class="string">b"rabz "</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(<span class="string">b"foo baz bar"</span>.rfind_byteset(<span class="string">b"\n123"</span>), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_not_byteset" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1042-1044">source</a><h4 class="code-header">fn <a href="#method.rfind_not_byteset" class="fn">rfind_not_byteset</a>&lt;B: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, byteset: B) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the last occurrence of a byte that is not a member
of the provided set.</p>
<p>The <code>byteset</code> may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>, but
note that passing a <code>&amp;str</code> which contains multibyte characters may not
behave as you expect: each byte in the <code>&amp;str</code> is treated as an
individual member of the byte set.</p>
<p>Note that order is irrelevant for the <code>byteset</code> parameter, and
duplicate bytes present in its body are ignored.</p>
<h5 id="complexity-7"><a class="doc-anchor" href="#complexity-7">§</a>Complexity</h5>
<p>This routine is guaranteed to have worst case linear time complexity
with respect to both the set of bytes and the haystack. That is, this
runs in <code>O(byteset.len() + haystack.len())</code> time.</p>
<p>This routine is also guaranteed to have worst case constant space
complexity.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="string">b"foo bar baz,\t"</span>.rfind_not_byteset(<span class="string">b",\t"</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(<span class="string">b"foo baz bar"</span>.rfind_not_byteset(<span class="string">b"rabz "</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"foo baz bar"</span>.rfind_not_byteset(<span class="string">b"barfoz "</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fields" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1069-1071">source</a><h4 class="code-header">fn <a href="#method.fields" class="fn">fields</a>(&amp;self) -&gt; <a class="struct" href="struct.Fields.html" title="struct bstr::Fields">Fields</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Fields&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the fields in a byte string, separated by
contiguous whitespace.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">"  foo\tbar\t\u{2003}\nquux   \n"</span>);
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.fields().collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[B(<span class="string">"foo"</span>), B(<span class="string">"bar"</span>), B(<span class="string">"quux"</span>)]);</code></pre></div>
<p>A byte string consisting of just whitespace yields no elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert_eq!</span>(<span class="number">0</span>, B(<span class="string">"  \n\t\u{2003}\n  \t"</span>).fields().count());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fields_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1101-1103">source</a><h4 class="code-header">fn <a href="#method.fields_with" class="fn">fields_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, f: F) -&gt; <a class="struct" href="struct.FieldsWith.html" title="struct bstr::FieldsWith">FieldsWith</a>&lt;'_, F&gt; <a href="#" class="tooltip" data-notable-ty="FieldsWith&lt;&#39;_, F&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the fields in a byte string, separated by
contiguous codepoints satisfying the given predicate.</p>
<p>If this byte string is not valid UTF-8, then the given closure will
be called with a Unicode replacement codepoint when invalid UTF-8
bytes are seen.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b"123foo999999bar1quux123456"</span>;
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.fields_with(|c| c.is_numeric()).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[B(<span class="string">"foo"</span>), B(<span class="string">"bar"</span>), B(<span class="string">"quux"</span>)]);</code></pre></div>
<p>A byte string consisting of all codepoints satisfying the predicate
yields no elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="number">0</span>, <span class="string">b"1911354563"</span>.fields_with(|c| c.is_numeric()).count());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1194-1199">source</a><h4 class="code-header">fn <a href="#method.split_str" class="fn">split_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
) -&gt; <a class="struct" href="struct.Split.html" title="struct bstr::Split">Split</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;a&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this byte string, separated
by the given byte string. Each element yielded is guaranteed not to
include the splitter substring.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"Mary had a little lamb"</span>.split_str(<span class="string">" "</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">"Mary"</span>), B(<span class="string">"had"</span>), B(<span class="string">"a"</span>), B(<span class="string">"little"</span>), B(<span class="string">"lamb"</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b""</span>.split_str(<span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b""</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"lionXXtigerXleopard"</span>.split_str(<span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"lion"</span>), B(<span class="string">""</span>), B(<span class="string">"tiger"</span>), B(<span class="string">"leopard"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"lion::tiger::leopard"</span>.split_str(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"lion"</span>), B(<span class="string">"tiger"</span>), B(<span class="string">"leopard"</span>)]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings yielded by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"||||a||b|c"</span>.split_str(<span class="string">"|"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">"a"</span>), B(<span class="string">""</span>), B(<span class="string">"b"</span>), B(<span class="string">"c"</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"(///)"</span>.split_str(<span class="string">"/"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"("</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">")"</span>)]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored by empty
strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"010"</span>.split_str(<span class="string">"0"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">""</span>), B(<span class="string">"1"</span>), B(<span class="string">""</span>)]);</code></pre></div>
<p>When the empty string is used as a separator, it splits every <strong>byte</strong>
in the byte string, along with the beginning and end of the byte
string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"rust"</span>.split_str(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">""</span>), B(<span class="string">"r"</span>), B(<span class="string">"u"</span>), B(<span class="string">"s"</span>), B(<span class="string">"t"</span>), B(<span class="string">""</span>),
]);

<span class="comment">// Splitting by an empty string is not UTF-8 aware. Elements yielded
// may not be valid UTF-8!
</span><span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = B(<span class="string">"☃"</span>).split_str(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">""</span>), B(<span class="string">b"\xE2"</span>), B(<span class="string">b"\x98"</span>), B(<span class="string">b"\x83"</span>), B(<span class="string">""</span>),
]);</code></pre></div>
<p>Contiguous separators, especially whitespace, can lead to possibly
surprising behavior. For example, this code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"    a  b c"</span>.split_str(<span class="string">" "</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">"a"</span>), B(<span class="string">""</span>), B(<span class="string">"b"</span>), B(<span class="string">"c"</span>),
]);</code></pre></div>
<p>It does <em>not</em> give you <code>["a", "b", "c"]</code>. For that behavior, use
<a href="#method.fields"><code>fields</code></a> instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1288-1293">source</a><h4 class="code-header">fn <a href="#method.rsplit_str" class="fn">rsplit_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
) -&gt; <a class="struct" href="struct.SplitReverse.html" title="struct bstr::SplitReverse">SplitReverse</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="SplitReverse&lt;&#39;a&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this byte string, separated by
the given byte string, in reverse. Each element yielded is guaranteed
not to include the splitter substring.</p>
<p>The splitter may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; =
    <span class="string">b"Mary had a little lamb"</span>.rsplit_str(<span class="string">" "</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">"lamb"</span>), B(<span class="string">"little"</span>), B(<span class="string">"a"</span>), B(<span class="string">"had"</span>), B(<span class="string">"Mary"</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b""</span>.rsplit_str(<span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b""</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"lionXXtigerXleopard"</span>.rsplit_str(<span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"leopard"</span>), B(<span class="string">"tiger"</span>), B(<span class="string">""</span>), B(<span class="string">"lion"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"lion::tiger::leopard"</span>.rsplit_str(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"leopard"</span>), B(<span class="string">"tiger"</span>), B(<span class="string">"lion"</span>)]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings yielded by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"||||a||b|c"</span>.rsplit_str(<span class="string">"|"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">"c"</span>), B(<span class="string">"b"</span>), B(<span class="string">""</span>), B(<span class="string">"a"</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>),
]);

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"(///)"</span>.rsplit_str(<span class="string">"/"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">")"</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">"("</span>)]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored by empty
strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"010"</span>.rsplit_str(<span class="string">"0"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">""</span>), B(<span class="string">"1"</span>), B(<span class="string">""</span>)]);</code></pre></div>
<p>When the empty string is used as a separator, it splits every <strong>byte</strong>
in the byte string, along with the beginning and end of the byte
string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"rust"</span>.rsplit_str(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">""</span>), B(<span class="string">"t"</span>), B(<span class="string">"s"</span>), B(<span class="string">"u"</span>), B(<span class="string">"r"</span>), B(<span class="string">""</span>),
]);

<span class="comment">// Splitting by an empty string is not UTF-8 aware. Elements yielded
// may not be valid UTF-8!
</span><span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = B(<span class="string">"☃"</span>).rsplit_str(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">""</span>), B(<span class="string">b"\x83"</span>), B(<span class="string">b"\x98"</span>), B(<span class="string">b"\xE2"</span>), B(<span class="string">""</span>)]);</code></pre></div>
<p>Contiguous separators, especially whitespace, can lead to possibly
surprising behavior. For example, this code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="string">b"    a  b c"</span>.rsplit_str(<span class="string">" "</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[
    B(<span class="string">"c"</span>), B(<span class="string">"b"</span>), B(<span class="string">""</span>), B(<span class="string">"a"</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">""</span>),
]);</code></pre></div>
<p>It does <em>not</em> give you <code>["a", "b", "c"]</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1331-1337">source</a><h4 class="code-header">fn <a href="#method.splitn_str" class="fn">splitn_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    limit: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
) -&gt; <a class="struct" href="struct.SplitN.html" title="struct bstr::SplitN">SplitN</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;a&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of this byte string,
separated by the given byte string. If <code>limit</code> substrings are yielded,
then the last substring will contain the remainder of this byte string.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"Mary had a little lamb"</span>.splitn_str(<span class="number">3</span>, <span class="string">" "</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"Mary"</span>), B(<span class="string">"had"</span>), B(<span class="string">"a little lamb"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b""</span>.splitn_str(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b""</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"lionXXtigerXleopard"</span>.splitn_str(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"lion"</span>), B(<span class="string">""</span>), B(<span class="string">"tigerXleopard"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"lion::tiger::leopard"</span>.splitn_str(<span class="number">2</span>, <span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"lion"</span>), B(<span class="string">"tiger::leopard"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"abcXdef"</span>.splitn_str(<span class="number">1</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"abcXdef"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"abcdef"</span>.splitn_str(<span class="number">2</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"abcdef"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"abcXdef"</span>.splitn_str(<span class="number">0</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert!</span>(x.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1377-1383">source</a><h4 class="code-header">fn <a href="#method.rsplitn_str" class="fn">rsplitn_str</a>&lt;'a, B: ?<a class="trait" href="https://doc.rust-lang.org/1.81.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;'a self,
    limit: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>,
    splitter: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.reference.html">&amp;'a B</a>,
) -&gt; <a class="struct" href="struct.SplitNReverse.html" title="struct bstr::SplitNReverse">SplitNReverse</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="SplitNReverse&lt;&#39;a&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of this byte string,
separated by the given byte string, in reverse. If <code>limit</code> substrings
are yielded, then the last substring will contain the remainder of this
byte string.</p>
<p>The needle may be any type that can be cheaply converted into a
<code>&amp;[u8]</code>. This includes, but is not limited to, <code>&amp;str</code> and <code>&amp;[u8]</code>.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; =
    <span class="string">b"Mary had a little lamb"</span>.rsplitn_str(<span class="number">3</span>, <span class="string">" "</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"lamb"</span>), B(<span class="string">"little"</span>), B(<span class="string">"Mary had a"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b""</span>.rsplitn_str(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[<span class="string">b""</span>]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"lionXXtigerXleopard"</span>.rsplitn_str(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"leopard"</span>), B(<span class="string">"tiger"</span>), B(<span class="string">"lionX"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"lion::tiger::leopard"</span>.rsplitn_str(<span class="number">2</span>, <span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"leopard"</span>), B(<span class="string">"lion::tiger"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"abcXdef"</span>.rsplitn_str(<span class="number">1</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"abcXdef"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"abcdef"</span>.rsplitn_str(<span class="number">2</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(x, <span class="macro">vec!</span>[B(<span class="string">"abcdef"</span>)]);

<span class="kw">let </span>x: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">b"abcXdef"</span>.rsplitn_str(<span class="number">0</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert!</span>(x.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1621-1623">source</a><h4 class="code-header">fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="struct.Bytes.html" title="struct bstr::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the bytes in this byte string.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"foobar"</span>;
<span class="kw">let </span>bytes: Vec&lt;u8&gt; = bs.bytes().collect();
<span class="macro">assert_eq!</span>(bytes, bs);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1651-1653">source</a><h4 class="code-header">fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="struct.Chars.html" title="struct bstr::Chars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the Unicode scalar values in this byte string.
If invalid UTF-8 is encountered, then the Unicode replacement codepoint
is yielded instead.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61"</span>;
<span class="kw">let </span>chars: Vec&lt;char&gt; = bs.chars().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">'☃'</span>, <span class="string">'\u{FFFD}'</span>, <span class="string">'𝞃'</span>, <span class="string">'\u{FFFD}'</span>, <span class="string">'a'</span>], chars);</code></pre></div>
<p>Codepoints can also be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61"</span>;
<span class="kw">let </span>chars: Vec&lt;char&gt; = bs.chars().rev().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">'a'</span>, <span class="string">'\u{FFFD}'</span>, <span class="string">'𝞃'</span>, <span class="string">'\u{FFFD}'</span>, <span class="string">'☃'</span>], chars);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1706-1708">source</a><h4 class="code-header">fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.CharIndices.html" title="struct bstr::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the Unicode scalar values in this byte string
along with their starting and ending byte index positions. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<p>Note that this is slightly different from the <code>CharIndices</code> iterator
provided by the standard library. Aside from working on possibly
invalid UTF-8, this iterator provides both the corresponding starting
and ending byte indices of each codepoint yielded. The ending position
is necessary to slice the original byte string when invalid UTF-8 bytes
are converted into a Unicode replacement codepoint, since a single
replacement codepoint can substitute anywhere from 1 to 3 invalid bytes
(inclusive).</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61"</span>;
<span class="kw">let </span>chars: Vec&lt;(usize, usize, char)&gt; = bs.char_indices().collect();
<span class="macro">assert_eq!</span>(chars, <span class="macro">vec!</span>[
    (<span class="number">0</span>, <span class="number">3</span>, <span class="string">'☃'</span>),
    (<span class="number">3</span>, <span class="number">4</span>, <span class="string">'\u{FFFD}'</span>),
    (<span class="number">4</span>, <span class="number">8</span>, <span class="string">'𝞃'</span>),
    (<span class="number">8</span>, <span class="number">10</span>, <span class="string">'\u{FFFD}'</span>),
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">'a'</span>),
]);</code></pre></div>
<p>Codepoints can also be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"\xE2\x98\x83\xFF\xF0\x9D\x9E\x83\xE2\x98\x61"</span>;
<span class="kw">let </span>chars: Vec&lt;(usize, usize, char)&gt; = bs
    .char_indices()
    .rev()
    .collect();
<span class="macro">assert_eq!</span>(chars, <span class="macro">vec!</span>[
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">'a'</span>),
    (<span class="number">8</span>, <span class="number">10</span>, <span class="string">'\u{FFFD}'</span>),
    (<span class="number">4</span>, <span class="number">8</span>, <span class="string">'𝞃'</span>),
    (<span class="number">3</span>, <span class="number">4</span>, <span class="string">'\u{FFFD}'</span>),
    (<span class="number">0</span>, <span class="number">3</span>, <span class="string">'☃'</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.utf8_chunks" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1743-1745">source</a><h4 class="code-header">fn <a href="#method.utf8_chunks" class="fn">utf8_chunks</a>(&amp;self) -&gt; <a class="struct" href="struct.Utf8Chunks.html" title="struct bstr::Utf8Chunks">Utf8Chunks</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Utf8Chunks&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over chunks of valid UTF-8.</p>
<p>The iterator returned yields chunks of valid UTF-8 separated by invalid
UTF-8 bytes, if they exist. Invalid UTF-8 bytes are always 1-3 bytes,
which are determined via the “substitution of maximal subparts”
strategy described in the docs for the
<a href="trait.ByteSlice.html#method.to_str_lossy"><code>ByteSlice::to_str_lossy</code></a>
method.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">§</a>Examples</h5>
<p>This example shows how to gather all valid and invalid chunks from a
byte slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{ByteSlice, Utf8Chunk};

<span class="kw">let </span>bytes = <span class="string">b"foo\xFD\xFEbar\xFF"</span>;

<span class="kw">let </span>(<span class="kw-2">mut </span>valid_chunks, <span class="kw-2">mut </span>invalid_chunks) = (<span class="macro">vec!</span>[], <span class="macro">vec!</span>[]);
<span class="kw">for </span>chunk <span class="kw">in </span>bytes.utf8_chunks() {
    <span class="kw">if </span>!chunk.valid().is_empty() {
        valid_chunks.push(chunk.valid());
    }
    <span class="kw">if </span>!chunk.invalid().is_empty() {
        invalid_chunks.push(chunk.invalid());
    }
}

<span class="macro">assert_eq!</span>(valid_chunks, <span class="macro">vec!</span>[<span class="string">"foo"</span>, <span class="string">"bar"</span>]);
<span class="macro">assert_eq!</span>(invalid_chunks, <span class="macro">vec!</span>[<span class="string">b"\xFD"</span>, <span class="string">b"\xFE"</span>, <span class="string">b"\xFF"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.graphemes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1775-1777">source</a><h4 class="code-header">fn <a href="#method.graphemes" class="fn">graphemes</a>(&amp;self) -&gt; <a class="struct" href="struct.Graphemes.html" title="struct bstr::Graphemes">Graphemes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Graphemes&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the grapheme clusters in this byte string.
If invalid UTF-8 is encountered, then the Unicode replacement codepoint
is yielded instead.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">§</a>Examples</h5>
<p>This example shows how multiple codepoints can combine to form a
single grapheme cluster:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">"a\u{0300}\u{0316}\u{1F1FA}\u{1F1F8}"</span>.as_bytes();
<span class="kw">let </span>graphemes: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = bs.graphemes().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">"à̖"</span>, <span class="string">"🇺🇸"</span>], graphemes);</code></pre></div>
<p>This shows that graphemes can be iterated over in reverse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">"a\u{0300}\u{0316}\u{1F1FA}\u{1F1F8}"</span>.as_bytes();
<span class="kw">let </span>graphemes: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = bs.graphemes().rev().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">"🇺🇸"</span>, <span class="string">"à̖"</span>], graphemes);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.grapheme_indices" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1819-1821">source</a><h4 class="code-header">fn <a href="#method.grapheme_indices" class="fn">grapheme_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.GraphemeIndices.html" title="struct bstr::GraphemeIndices">GraphemeIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="GraphemeIndices&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the grapheme clusters in this byte string
along with their starting and ending byte index positions. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">§</a>Examples</h5>
<p>This example shows how to get the byte offsets of each individual
grapheme cluster:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">"a\u{0300}\u{0316}\u{1F1FA}\u{1F1F8}"</span>.as_bytes();
<span class="kw">let </span>graphemes: Vec&lt;(usize, usize, <span class="kw-2">&amp;</span>str)&gt; =
    bs.grapheme_indices().collect();
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">5</span>, <span class="string">"à̖"</span>), (<span class="number">5</span>, <span class="number">13</span>, <span class="string">"🇺🇸"</span>)], graphemes);</code></pre></div>
<p>This example shows what happens when invalid UTF-8 is enountered. Note
that the offsets are valid indices into the original string, and do
not necessarily correspond to the length of the <code>&amp;str</code> returned!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{ByteSlice, ByteVec};

<span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="macro">vec!</span>[];
bytes.push_str(<span class="string">"a\u{0300}\u{0316}"</span>);
bytes.push(<span class="string">b'\xFF'</span>);
bytes.push_str(<span class="string">"\u{1F1FA}\u{1F1F8}"</span>);

<span class="kw">let </span>graphemes: Vec&lt;(usize, usize, <span class="kw-2">&amp;</span>str)&gt; =
    bytes.grapheme_indices().collect();
<span class="macro">assert_eq!</span>(
    graphemes,
    <span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">5</span>, <span class="string">"à̖"</span>), (<span class="number">5</span>, <span class="number">6</span>, <span class="string">"\u{FFFD}"</span>), (<span class="number">6</span>, <span class="number">14</span>, <span class="string">"🇺🇸"</span>)]
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.words" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1855-1857">source</a><h4 class="code-header">fn <a href="#method.words" class="fn">words</a>(&amp;self) -&gt; <a class="struct" href="struct.Words.html" title="struct bstr::Words">Words</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Words&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the words in this byte string. If invalid
UTF-8 is encountered, then the Unicode replacement codepoint is yielded
instead.</p>
<p>This is similar to
<a href="trait.ByteSlice.html#method.words_with_breaks"><code>words_with_breaks</code></a>,
except it only returns elements that contain a “word” character. A word
character is defined by UTS #18 (Annex C) to be the combination of the
<code>Alphabetic</code> and <code>Join_Control</code> properties, along with the
<code>Decimal_Number</code>, <code>Mark</code> and <code>Connector_Punctuation</code> general
categories.</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">br#"The quick ("brown") fox can't jump 32.3 feet, right?"#</span>;
<span class="kw">let </span>words: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = bs.words().collect();
<span class="macro">assert_eq!</span>(words, <span class="macro">vec!</span>[
    <span class="string">"The"</span>, <span class="string">"quick"</span>, <span class="string">"brown"</span>, <span class="string">"fox"</span>, <span class="string">"can't"</span>,
    <span class="string">"jump"</span>, <span class="string">"32.3"</span>, <span class="string">"feet"</span>, <span class="string">"right"</span>,
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.word_indices" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1893-1895">source</a><h4 class="code-header">fn <a href="#method.word_indices" class="fn">word_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.WordIndices.html" title="struct bstr::WordIndices">WordIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="WordIndices&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the words in this byte string along with
their starting and ending byte index positions.</p>
<p>This is similar to
<a href="trait.ByteSlice.html#method.words_with_break_indices"><code>words_with_break_indices</code></a>,
except it only returns elements that contain a “word” character. A word
character is defined by UTS #18 (Annex C) to be the combination of the
<code>Alphabetic</code> and <code>Join_Control</code> properties, along with the
<code>Decimal_Number</code>, <code>Mark</code> and <code>Connector_Punctuation</code> general
categories.</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">§</a>Examples</h5>
<p>This example shows how to get the byte offsets of each individual
word:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"can't jump 32.3 feet"</span>;
<span class="kw">let </span>words: Vec&lt;(usize, usize, <span class="kw-2">&amp;</span>str)&gt; = bs.word_indices().collect();
<span class="macro">assert_eq!</span>(words, <span class="macro">vec!</span>[
    (<span class="number">0</span>, <span class="number">5</span>, <span class="string">"can't"</span>),
    (<span class="number">6</span>, <span class="number">10</span>, <span class="string">"jump"</span>),
    (<span class="number">11</span>, <span class="number">15</span>, <span class="string">"32.3"</span>),
    (<span class="number">16</span>, <span class="number">20</span>, <span class="string">"feet"</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.words_with_breaks" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1923-1925">source</a><h4 class="code-header">fn <a href="#method.words_with_breaks" class="fn">words_with_breaks</a>(&amp;self) -&gt; <a class="struct" href="struct.WordsWithBreaks.html" title="struct bstr::WordsWithBreaks">WordsWithBreaks</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="WordsWithBreaks&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the words in this byte string, along with
all breaks between the words. Concatenating all elements yielded by
the iterator results in the original string (modulo Unicode replacement
codepoint substitutions if invalid UTF-8 is encountered).</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">br#"The quick ("brown") fox can't jump 32.3 feet, right?"#</span>;
<span class="kw">let </span>words: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = bs.words_with_breaks().collect();
<span class="macro">assert_eq!</span>(words, <span class="macro">vec!</span>[
    <span class="string">"The"</span>, <span class="string">" "</span>, <span class="string">"quick"</span>, <span class="string">" "</span>, <span class="string">"("</span>, <span class="string">"\""</span>, <span class="string">"brown"</span>, <span class="string">"\""</span>, <span class="string">")"</span>,
    <span class="string">" "</span>, <span class="string">"fox"</span>, <span class="string">" "</span>, <span class="string">"can't"</span>, <span class="string">" "</span>, <span class="string">"jump"</span>, <span class="string">" "</span>, <span class="string">"32.3"</span>, <span class="string">" "</span>, <span class="string">"feet"</span>,
    <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"right"</span>, <span class="string">"?"</span>,
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.words_with_break_indices" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1960-1962">source</a><h4 class="code-header">fn <a href="#method.words_with_break_indices" class="fn">words_with_break_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.WordsWithBreakIndices.html" title="struct bstr::WordsWithBreakIndices">WordsWithBreakIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="WordsWithBreakIndices&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the words and their byte offsets in this
byte string, along with all breaks between the words. Concatenating
all elements yielded by the iterator results in the original string
(modulo Unicode replacement codepoint substitutions if invalid UTF-8 is
encountered).</p>
<p>Since words are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">§</a>Examples</h5>
<p>This example shows how to get the byte offsets of each individual
word:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"can't jump 32.3 feet"</span>;
<span class="kw">let </span>words: Vec&lt;(usize, usize, <span class="kw-2">&amp;</span>str)&gt; =
    bs.words_with_break_indices().collect();
<span class="macro">assert_eq!</span>(words, <span class="macro">vec!</span>[
    (<span class="number">0</span>, <span class="number">5</span>, <span class="string">"can't"</span>),
    (<span class="number">5</span>, <span class="number">6</span>, <span class="string">" "</span>),
    (<span class="number">6</span>, <span class="number">10</span>, <span class="string">"jump"</span>),
    (<span class="number">10</span>, <span class="number">11</span>, <span class="string">" "</span>),
    (<span class="number">11</span>, <span class="number">15</span>, <span class="string">"32.3"</span>),
    (<span class="number">15</span>, <span class="number">16</span>, <span class="string">" "</span>),
    (<span class="number">16</span>, <span class="number">20</span>, <span class="string">"feet"</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sentences" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#1992-1994">source</a><h4 class="code-header">fn <a href="#method.sentences" class="fn">sentences</a>(&amp;self) -&gt; <a class="struct" href="struct.Sentences.html" title="struct bstr::Sentences">Sentences</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Sentences&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the sentences in this byte string.</p>
<p>Typically, a sentence will include its trailing punctuation and
whitespace. Concatenating all elements yielded by the iterator
results in the original string (modulo Unicode replacement codepoint
substitutions if invalid UTF-8 is encountered).</p>
<p>Since sentences are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"I want this. Not that. Right now."</span>;
<span class="kw">let </span>sentences: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = bs.sentences().collect();
<span class="macro">assert_eq!</span>(sentences, <span class="macro">vec!</span>[
    <span class="string">"I want this. "</span>,
    <span class="string">"Not that. "</span>,
    <span class="string">"Right now."</span>,
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sentence_indices" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2026-2028">source</a><h4 class="code-header">fn <a href="#method.sentence_indices" class="fn">sentence_indices</a>(&amp;self) -&gt; <a class="struct" href="struct.SentenceIndices.html" title="struct bstr::SentenceIndices">SentenceIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SentenceIndices&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the sentences in this byte string along with
their starting and ending byte index positions.</p>
<p>Typically, a sentence will include its trailing punctuation and
whitespace. Concatenating all elements yielded by the iterator
results in the original string (modulo Unicode replacement codepoint
substitutions if invalid UTF-8 is encountered).</p>
<p>Since sentences are made up of one or more codepoints, this iterator
yields <code>&amp;str</code> elements. When invalid UTF-8 is encountered, replacement
codepoints are <a href="index.html#handling-of-invalid-utf-8">substituted</a>.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span>bs = <span class="string">b"I want this. Not that. Right now."</span>;
<span class="kw">let </span>sentences: Vec&lt;(usize, usize, <span class="kw-2">&amp;</span>str)&gt; =
    bs.sentence_indices().collect();
<span class="macro">assert_eq!</span>(sentences, <span class="macro">vec!</span>[
    (<span class="number">0</span>, <span class="number">13</span>, <span class="string">"I want this. "</span>),
    (<span class="number">13</span>, <span class="number">23</span>, <span class="string">"Not that. "</span>),
    (<span class="number">23</span>, <span class="number">33</span>, <span class="string">"Right now."</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2057-2059">source</a><h4 class="code-header">fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="struct.Lines.html" title="struct bstr::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator over all lines in a byte string, without their
terminators.</p>
<p>For this iterator, the only line terminators recognized are <code>\r\n</code> and
<code>\n</code>.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b"\
foo

bar\r
baz


quux"</span>;
<span class="kw">let </span>lines: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.lines().collect();
<span class="macro">assert_eq!</span>(lines, <span class="macro">vec!</span>[
    B(<span class="string">"foo"</span>), B(<span class="string">""</span>), B(<span class="string">"bar"</span>), B(<span class="string">"baz"</span>), B(<span class="string">""</span>), B(<span class="string">""</span>), B(<span class="string">"quux"</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_with_terminator" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2101-2103">source</a><h4 class="code-header">fn <a href="#method.lines_with_terminator" class="fn">lines_with_terminator</a>(&amp;self) -&gt; <a class="struct" href="struct.LinesWithTerminator.html" title="struct bstr::LinesWithTerminator">LinesWithTerminator</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesWithTerminator&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>An iterator over all lines in a byte string, including their
terminators.</p>
<p>For this iterator, the only line terminator recognized is <code>\n</code>. (Since
line terminators are included, this also handles <code>\r\n</code> line endings.)</p>
<p>Line terminators are only included if they are present in the original
byte string. For example, the last line in a byte string may not end
with a line terminator.</p>
<p>Concatenating all elements yielded by this iterator is guaranteed to
yield the original byte string.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b"\
foo

bar\r
baz


quux"</span>;
<span class="kw">let </span>lines: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = s.lines_with_terminator().collect();
<span class="macro">assert_eq!</span>(lines, <span class="macro">vec!</span>[
    B(<span class="string">"foo\n"</span>),
    B(<span class="string">"\n"</span>),
    B(<span class="string">"bar\r\n"</span>),
    B(<span class="string">"baz\n"</span>),
    B(<span class="string">"\n"</span>),
    B(<span class="string">"\n"</span>),
    B(<span class="string">"quux"</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2123-2125">source</a><h4 class="code-header">fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with leading and trailing whitespace
removed.</p>
<p>Whitespace is defined according to the terms of the <code>White_Space</code>
Unicode property.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">" foo\tbar\t\u{2003}\n"</span>);
<span class="macro">assert_eq!</span>(s.trim(), B(<span class="string">"foo\tbar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2144-2147">source</a><h4 class="code-header">fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with leading whitespace removed.</p>
<p>Whitespace is defined according to the terms of the <code>White_Space</code>
Unicode property.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">" foo\tbar\t\u{2003}\n"</span>);
<span class="macro">assert_eq!</span>(s.trim_start(), B(<span class="string">"foo\tbar\t\u{2003}\n"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2166-2169">source</a><h4 class="code-header">fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with trailing whitespace removed.</p>
<p>Whitespace is defined according to the terms of the <code>White_Space</code>
Unicode property.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = B(<span class="string">" foo\tbar\t\u{2003}\n"</span>);
<span class="macro">assert_eq!</span>(s.trim_end(), B(<span class="string">" foo\tbar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2185-2187">source</a><h4 class="code-header">fn <a href="#method.trim_with" class="fn">trim_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with leading and trailing characters
satisfying the given predicate removed.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b"123foo5bar789"</span>;
<span class="macro">assert_eq!</span>(s.trim_with(|c| c.is_numeric()), B(<span class="string">"foo5bar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2203-2210">source</a><h4 class="code-header">fn <a href="#method.trim_start_with" class="fn">trim_start_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with leading characters satisfying the given
predicate removed.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b"123foo5bar789"</span>;
<span class="macro">assert_eq!</span>(s.trim_start_with(|c| c.is_numeric()), B(<span class="string">"foo5bar789"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_with" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2226-2233">source</a><h4 class="code-header">fn <a href="#method.trim_end_with" class="fn">trim_end_with</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a>&gt;(&amp;self, trim: F) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a byte string slice with trailing characters satisfying the
given predicate removed.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span>s = <span class="string">b"123foo5bar789"</span>;
<span class="macro">assert_eq!</span>(s.trim_end_with(|c| c.is_numeric()), B(<span class="string">"123foo5bar"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_lowercase" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2434-2436">source</a><h4 class="code-header">fn <a href="#method.make_ascii_lowercase" class="fn">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Convert this byte string to its lowercase ASCII equivalent in place.</p>
<p>In this case, lowercase is only defined in ASCII letters. Namely, the
letters <code>A-Z</code> are converted to <code>a-z</code>. All other bytes remain unchanged.</p>
<p>If you don’t need to do the conversion in
place and instead prefer convenience, then use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase</code></a> instead.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"HELLO Β"</span>);
s.make_ascii_lowercase();
<span class="macro">assert_eq!</span>(s, <span class="string">"hello Β"</span>.as_bytes());</code></pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice, ByteVec};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from_slice(<span class="string">b"FOO\xFFBAR\xE2\x98BAZ"</span>);
s.make_ascii_lowercase();
<span class="macro">assert_eq!</span>(s, B(<span class="string">b"foo\xFFbar\xE2\x98baz"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_ascii_uppercase" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2634-2636">source</a><h4 class="code-header">fn <a href="#method.make_ascii_uppercase" class="fn">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Convert this byte string to its uppercase ASCII equivalent in place.</p>
<p>In this case, uppercase is only defined in ASCII letters. Namely, the
letters <code>a-z</code> are converted to <code>A-Z</code>. All other bytes remain unchanged.</p>
<p>If you don’t need to do the conversion in
place and instead prefer convenience, then use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase</code></a> instead.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"hello β"</span>);
s.make_ascii_uppercase();
<span class="macro">assert_eq!</span>(s, B(<span class="string">"HELLO β"</span>));</code></pre></div>
<p>Invalid UTF-8 remains as is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice, ByteVec};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from_slice(<span class="string">b"foo\xFFbar\xE2\x98baz"</span>);
s.make_ascii_uppercase();
<span class="macro">assert_eq!</span>(s, B(<span class="string">b"FOO\xFFBAR\xE2\x98BAZ"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_bytes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2661-2663">source</a><h4 class="code-header">fn <a href="#method.reverse_bytes" class="fn">reverse_bytes</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverse the bytes in this string, in place.</p>
<p>This is not necessarily a well formed operation! For example, if this
byte string contains valid UTF-8 that isn’t ASCII, then reversing the
string will likely result in invalid UTF-8 and otherwise non-sensical
content.</p>
<p>Note that this is equivalent to the generic <code>[u8]::reverse</code> method.
This method is provided to permit callers to explicitly differentiate
between reversing bytes, codepoints and graphemes.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"hello"</span>);
s.reverse_bytes();
<span class="macro">assert_eq!</span>(s, <span class="string">"olleh"</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_chars" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2732-2745">source</a><h4 class="code-header">fn <a href="#method.reverse_chars" class="fn">reverse_chars</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverse the codepoints in this string, in place.</p>
<p>If this byte string is valid UTF-8, then its reversal by codepoint
is also guaranteed to be valid UTF-8.</p>
<p>This operation is equivalent to the following, but without allocating:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"foo☃bar"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>chars: Vec&lt;char&gt; = s.chars().collect();
chars.reverse();

<span class="kw">let </span>reversed: String = chars.into_iter().collect();
<span class="macro">assert_eq!</span>(reversed, <span class="string">"rab☃oof"</span>);</code></pre></div>
<p>Note that this is not necessarily a well formed operation. For example,
if this byte string contains grapheme clusters with more than one
codepoint, then those grapheme clusters will not necessarily be
preserved. If you’d like to preserve grapheme clusters, then use
<a href="#method.reverse_graphemes"><code>reverse_graphemes</code></a> instead.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"foo☃bar"</span>);
s.reverse_chars();
<span class="macro">assert_eq!</span>(s, <span class="string">"rab☃oof"</span>.as_bytes());</code></pre></div>
<p>This example shows that not all reversals lead to a well formed string.
For example, in this case, combining marks are used to put accents over
some letters, and those accent marks must appear after the codepoints
they modify.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"résumé"</span>);
s.reverse_chars();
<span class="macro">assert_eq!</span>(s, B(<span class="string">b"\xCC\x81emus\xCC\x81er"</span>));</code></pre></div>
<p>A word of warning: the above example relies on the fact that
<code>résumé</code> is in decomposed normal form, which means there are separate
codepoints for the accents above <code>e</code>. If it is instead in composed
normal form, then the example works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"résumé"</span>);
s.reverse_chars();
<span class="macro">assert_eq!</span>(s, B(<span class="string">"émusér"</span>));</code></pre></div>
<p>The point here is to be cautious and not assume that just because
<code>reverse_chars</code> works in one case, that it therefore works in all
cases.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse_graphemes" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2790-2805">source</a><h4 class="code-header">fn <a href="#method.reverse_graphemes" class="fn">reverse_graphemes</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverse the graphemes in this string, in place.</p>
<p>If this byte string is valid UTF-8, then its reversal by grapheme
is also guaranteed to be valid UTF-8.</p>
<p>This operation is equivalent to the following, but without allocating:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"foo☃bar"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>graphemes: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = s.graphemes().collect();
graphemes.reverse();

<span class="kw">let </span>reversed = graphemes.concat();
<span class="macro">assert_eq!</span>(reversed, <span class="string">"rab☃oof"</span>);</code></pre></div>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"foo☃bar"</span>);
s.reverse_graphemes();
<span class="macro">assert_eq!</span>(s, <span class="string">"rab☃oof"</span>.as_bytes());</code></pre></div>
<p>This example shows how this correctly handles grapheme clusters,
unlike <code>reverse_chars</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="kw">let </span><span class="kw-2">mut </span>s = &lt;Vec&lt;u8&gt;&gt;::from(<span class="string">"résumé"</span>);
s.reverse_graphemes();
<span class="macro">assert_eq!</span>(s, <span class="string">"émusér"</span>.as_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2825-2827">source</a><h4 class="code-header">fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if every byte in this byte string is ASCII.</p>
<p>ASCII is an encoding that defines 128 codepoints. A byte corresponds to
an ASCII codepoint if and only if it is in the inclusive range
<code>[0, 127]</code>.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert!</span>(B(<span class="string">"abc"</span>).is_ascii());
<span class="macro">assert!</span>(!B(<span class="string">"☃βツ"</span>).is_ascii());
<span class="macro">assert!</span>(!B(<span class="string">b"\xFF"</span>).is_ascii());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_utf8" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2853-2855">source</a><h4 class="code-header">fn <a href="#method.is_utf8" class="fn">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the entire byte string is valid UTF-8.</p>
<p>If you need location information about where a byte string’s first
invalid UTF-8 byte is, then use the <a href="#method.to_str"><code>to_str</code></a> method.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="macro">assert!</span>(B(<span class="string">"abc"</span>).is_utf8());
<span class="macro">assert!</span>(B(<span class="string">"☃βツ"</span>).is_utf8());
<span class="comment">// invalid bytes
</span><span class="macro">assert!</span>(!B(<span class="string">b"abc\xFF"</span>).is_utf8());
<span class="comment">// surrogate encoding
</span><span class="macro">assert!</span>(!B(<span class="string">b"\xED\xA0\x80"</span>).is_utf8());
<span class="comment">// incomplete sequence
</span><span class="macro">assert!</span>(!B(<span class="string">b"\xF0\x9D\x9Ca"</span>).is_utf8());
<span class="comment">// overlong sequence
</span><span class="macro">assert!</span>(!B(<span class="string">b"\xF0\x82\x82\xAC"</span>).is_utf8());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2874-2877">source</a><h4 class="code-header">fn <a href="#method.last_byte" class="fn">last_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last byte in this byte string, if it’s non-empty. If this
byte string is empty, this returns <code>None</code>.</p>
<p>Note that this is like the generic <code>[u8]::last</code>, except this returns
the byte by value instead of a reference to the byte.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::ByteSlice;

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'z'</span>), <span class="string">b"baz"</span>.last_byte());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b""</span>.last_byte());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_non_ascii_byte" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2895-2902">source</a><h4 class="code-header">fn <a href="#method.find_non_ascii_byte" class="fn">find_non_ascii_byte</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.81.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the index of the first non-ASCII byte in this byte string (if
any such indices exist). Specifically, it returns the index of the
first byte with a value greater than or equal to <code>0x80</code>.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{ByteSlice, B};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="string">b"abc\xff"</span>.find_non_ascii_byte());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="string">b"abcde"</span>.find_non_ascii_byte());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), B(<span class="string">"😀"</span>).find_non_ascii_byte());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_within_str" class="method"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#2930-2968">source</a><h4 class="code-header">fn <a href="#method.copy_within_str" class="fn">copy_within_str</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>)<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.81.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.usize.html">usize</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Copies elements from one part of the slice to another part of itself,
where the parts may be overlapping.</p>
<p><code>src</code> is the range within this byte string to copy from, while <code>dest</code>
is the starting index of the range within this byte string to copy to.
The length indicated by <code>src</code> must be less than or equal to the number
of bytes from <code>dest</code> to the end of the byte string.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if either range is out of bounds, or if <code>src</code> is too big to fit
into <code>dest</code>, or if the end of <code>src</code> is before the start.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">§</a>Examples</h5>
<p>Copying four bytes within a byte string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bstr::{B, ByteSlice};

<span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw-2">*</span><span class="string">b"Hello, World!"</span>;
<span class="kw">let </span>s = <span class="kw-2">&amp;mut </span>buf;
s.copy_within_str(<span class="number">1</span>..<span class="number">5</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(s, B(<span class="string">"Hello, Wello!"</span>));</code></pre></div>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.81.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="foreign-impls" class="section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><section id="impl-ByteSlice-for-%5Bu8%5D" class="impl"><a class="src rightside" href="../src/bstr/ext_slice.rs.html#74-84">source</a><a href="#impl-ByteSlice-for-%5Bu8%5D" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.ByteSlice.html" title="trait bstr::ByteSlice">ByteSlice</a> for [<a class="primitive" href="https://doc.rust-lang.org/1.81.0/std/primitive.u8.html">u8</a>]</h3></section><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../trait.impl/bstr/ext_slice/trait.ByteSlice.js" data-ignore-extern-crates="std" async></script><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>]</div>","Bytes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Bytes.html\" title=\"struct bstr::Bytes\">Bytes</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Bytes.html\" title=\"struct bstr::Bytes\">Bytes</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>;</div>","CharIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.CharIndices.html\" title=\"struct bstr::CharIndices\">CharIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.CharIndices.html\" title=\"struct bstr::CharIndices\">CharIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.char.html\">char</a>);</div>","Chars<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Chars.html\" title=\"struct bstr::Chars\">Chars</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Chars.html\" title=\"struct bstr::Chars\">Chars</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.char.html\">char</a>;</div>","Fields<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Fields.html\" title=\"struct bstr::Fields\">Fields</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Fields.html\" title=\"struct bstr::Fields\">Fields</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","FieldsWith<'_, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FieldsWith.html\" title=\"struct bstr::FieldsWith\">FieldsWith</a>&lt;'a, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.char.html\">char</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.bool.html\">bool</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FieldsWith.html\" title=\"struct bstr::FieldsWith\">FieldsWith</a>&lt;'a, F&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","Find<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Find.html\" title=\"struct bstr::Find\">Find</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Find.html\" title=\"struct bstr::Find\">Find</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>;</div>","FindReverse<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindReverse.html\" title=\"struct bstr::FindReverse\">FindReverse</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindReverse.html\" title=\"struct bstr::FindReverse\">FindReverse</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>;</div>","GraphemeIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.GraphemeIndices.html\" title=\"struct bstr::GraphemeIndices\">GraphemeIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.GraphemeIndices.html\" title=\"struct bstr::GraphemeIndices\">GraphemeIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>);</div>","Graphemes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Graphemes.html\" title=\"struct bstr::Graphemes\">Graphemes</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Graphemes.html\" title=\"struct bstr::Graphemes\">Graphemes</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>;</div>","Lines<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Lines.html\" title=\"struct bstr::Lines\">Lines</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Lines.html\" title=\"struct bstr::Lines\">Lines</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","LinesWithTerminator<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.LinesWithTerminator.html\" title=\"struct bstr::LinesWithTerminator\">LinesWithTerminator</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.LinesWithTerminator.html\" title=\"struct bstr::LinesWithTerminator\">LinesWithTerminator</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","SentenceIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SentenceIndices.html\" title=\"struct bstr::SentenceIndices\">SentenceIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SentenceIndices.html\" title=\"struct bstr::SentenceIndices\">SentenceIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>);</div>","Sentences<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Sentences.html\" title=\"struct bstr::Sentences\">Sentences</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Sentences.html\" title=\"struct bstr::Sentences\">Sentences</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>;</div>","Split<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Split.html\" title=\"struct bstr::Split\">Split</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Split.html\" title=\"struct bstr::Split\">Split</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","SplitN<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SplitN.html\" title=\"struct bstr::SplitN\">SplitN</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SplitN.html\" title=\"struct bstr::SplitN\">SplitN</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","SplitNReverse<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SplitNReverse.html\" title=\"struct bstr::SplitNReverse\">SplitNReverse</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SplitNReverse.html\" title=\"struct bstr::SplitNReverse\">SplitNReverse</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","SplitReverse<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SplitReverse.html\" title=\"struct bstr::SplitReverse\">SplitReverse</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SplitReverse.html\" title=\"struct bstr::SplitReverse\">SplitReverse</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.u8.html\">u8</a>];</div>","Utf8Chunks<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Utf8Chunks.html\" title=\"struct bstr::Utf8Chunks\">Utf8Chunks</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Utf8Chunks.html\" title=\"struct bstr::Utf8Chunks\">Utf8Chunks</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.Utf8Chunk.html\" title=\"struct bstr::Utf8Chunk\">Utf8Chunk</a>&lt;'a&gt;;</div>","WordIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.WordIndices.html\" title=\"struct bstr::WordIndices\">WordIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.WordIndices.html\" title=\"struct bstr::WordIndices\">WordIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>);</div>","Words<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Words.html\" title=\"struct bstr::Words\">Words</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Words.html\" title=\"struct bstr::Words\">Words</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>;</div>","WordsWithBreakIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.WordsWithBreakIndices.html\" title=\"struct bstr::WordsWithBreakIndices\">WordsWithBreakIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.WordsWithBreakIndices.html\" title=\"struct bstr::WordsWithBreakIndices\">WordsWithBreakIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>);</div>","WordsWithBreaks<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.WordsWithBreaks.html\" title=\"struct bstr::WordsWithBreaks\">WordsWithBreaks</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.WordsWithBreaks.html\" title=\"struct bstr::WordsWithBreaks\">WordsWithBreaks</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.81.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.81.0/std/primitive.str.html\">str</a>;</div>"}</script></section></div></main></body></html>